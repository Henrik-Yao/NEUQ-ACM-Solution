#ACM 第一次双周赛题解
<p align="right"> **by 韩涵** 
<p align="right"> *编译器类型：vs2019、pycharm2021*

本次双周赛的题目主要针对递归，迭代，归并，分治的算法。详解如下：

---------------------
####7-1 最大子段和
本题既可以使用分治算法，动态规划，也可以进行递归或者迭代。发现递推公式是这题的关键（分治除外）

**题目详情：**
给定n个整数（可能为负数）组成的序列a[1],a[2],a[3],…,a[n]，求该序列如a[i]+a[i+1]+…+a[j]的子段和的最大值。当所给的整数均为负数时，定义子段和为0。要求算法的时间复杂度为O(n)。

**输入格式:**
输入有两行：第一行是n值（1<=n<=10000)，第二行是n个整数。

**输出格式:**
输出最大子段和。

**解题思路：**
本题我采用的动态规划。假设每个段一定选中最后一个数，长度为n数组的最大字段和可以分解为：第n个数和前n-1个数最大字段和。当前n-1个数为负数时就为最后一个数，否则就加上前n-1个数的最大字段和。（由于每次都选中段中最后一个数，不会出现段不连续的问题），移动所选段的段尾，讲所给段的字段遍历，并将每次求得的值去最大即为本题答案（详见代码）。

**c++代码：**


    #include<iostream>
	using namespace std;
 
    void Max(int n, int a[]){
	    int sum = 0;
	    int max = 0;
	    for(int i = 0; i<n; i++){
	        //求最大字段和
		    sum = (sum + a[i]) > a[i] ? 
		           (sum + a[i]) : a[i];
		    //记录最大字段和的最大值
            max = sum > max ? sum : max;
	    }
	    cout << max << endl;
    }
   
    int main(){
	    int n,a[10001];
	    cin >> n;
	    for(int i=0; i<n; i++) cin >> a[i];
	    Max(n,a);
	    return 0;
    } 

-------------------

####7-2 汉诺塔问题

本题是递归调用的最基础题型，也是学习递归的第一个例题，正确选择目标柱子即可，具体解题思路见下。

**题目详情：**
给定一个由n个圆盘组成的塔，这些圆盘按照大小递减的方式套在第一根桩柱上。现要将整个塔移动到另一根桩柱上，每次只能移动一个圆盘，且较大的圆盘在移动过程中不能放置在较小的圆盘上面。

**输入格式:**
输入由四行： 第一行是圆盘数量n(1<=n<=10); 第二行到第四行分别是三根桩柱的名字(字符串)，n个盘子套在第一根桩柱上。

**输出格式:**
输出移动步骤，每行输出一步。

**解题思路:**
本题盘子的移动可以分为3步：将上n-1个盘子从左柱移动到中间柱，将原最底下的柱子从左柱移动到右柱，将中间柱上的盘子移到右柱。而中间柱盘子的移动方法就是将原方法的左柱子和中间柱做交换,详细信息已在注释中给出。

**python代码:**
	
	def hanoi(a, b, c, d):  # a，b，c分别为一，二，三根柱子
	    if d > 1:  # 当 d = 1时就只有一个圆盘，不需要在进行递归
	    hanoi(a, c, b, d - 1)  # 将n-1个圆盘从a移动到b
	    print(a + "->" + c)
	    if d > 1:  # 同理
	        hanoi(b, a, c, d - 1)  # 将n-1个圆盘从b移动到c
	
	
	def week2_1():
	    n = int(input(""))
	    name = [input(""), input(""), input("")]
	    hanoi(name[0], name[1], name[2], n)
	
	
	if __name__ == '__main__':
	    week2_1()
**c++代码(无注释)：**

	#include<iostream>
	using namespace std;
	void han(string a,string b,string c,int d) {
		if (d > 1)han(a, c, b, d - 1);
		cout << a << "->" << c << endl;
		if (d > 1)han(b, a, c, d - 1);
	}
	int main() {
		int n;
		cin >> n;
		string name[3];
		for (int i = 0; i < 3; i++) cin >> name[i];
		han(name[0], name[1], name[2], n);
	}
	
---------------------

#### 7.3 汉诺塔 |||
本题可以使用通项公式进行解决，有大坑，后面详细说明。

**题目详情:**
约19世纪末，在欧州的商店中出售一种智力玩具，在一块铜板上有三根杆，最左边的杆上自上而下、由小到大顺序串着由64个圆盘构成的塔。目的是将最左边杆上的盘全部移到右边的杆上，条件是一次只能移动一个盘，且不允许大盘放在小盘的上面。 现在我们改变游戏的玩法，不允许直接从最左(右)边移到最右(左)边(每次移动一定是移到中间杆或从中间移出)，也不允许大盘放到下盘的上面。 Daisy已经做过原来的汉诺塔问题和汉诺塔II，但碰到这个问题时，她想了很久都不能解决，现在请你帮助她。现在有N个圆盘，她至少多少次移动才能把这些圆盘从最左边移到最右边？

**输入格式:**
包含多组数据，每次输入一个N值(1<=N=35)。

**输出格式:**
对于每组数据，输出移动最小的次数。

**解题思路：**
与汉诺塔问题相仿，本题可以分为5个步骤，假设有n个盘子在左面的柱子上：

1.将上面n-1个盘子移动到右面的柱子上
2.将第n个盘子移动到中间柱子上
3.将上面n-1个盘子移动到左面的柱子上
4.将第n个盘子移动到右面柱子上
5.将上面n-1个盘子移动到右面的柱子上

由此可得此题的递推公式为：
<center>**a[n] = a[n - 1] + 1 + a[n - 1] + 1 + a[n-1]**</center>
<center>**a[n] = 3*a[n-1] + 2**</center>
但到这里还没有结束，我们仍可以简化步骤，由递推得到通项公式为：
<center>**a[n] = 3 ^ n - 1**</center>

但还没有结束，由于最后的数据较大，所以还应该**注意**：
-使用 unsigned long long进行数据的存储
-不能使用math.h里的pow函数求值，会有精度损失
-使用“%l64d"作为print格式化输出里的数据类型

**c++代码：**

	#include<iostream>
	#include<math.h>
	typedef unsigned long long ull;
	using namespace std;
	int main() {
	    int a;
	    while (scanf("%d", &a) != EOF) {
	        long long int ans=1;
        for(int i=1;i<=a;i++) ans*=3;
		ans-=1;
		//使用cout也可
	    cout << ans << endl;
	    }
	}


---------------------

####7.4 汉诺塔 ||

本题采用动态规划和分治就可进行解决，数据类型较大，应使用 unsigned long long。

**题目详情：**
经典的汉诺塔问题经常作为一个递归的经典例题存在。可能有人并不知道汉诺塔问题的典故。汉诺塔来源于印度传说的一个故事，上帝创造世界时作了三根金刚石柱子，在一根柱子上从下往上按大小顺序摞着64片黄金圆盘。上帝命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一回只能移动一个圆盘。有预言说，这件事完成时宇宙会在一瞬间闪电式毁灭。也有人相信婆罗门至今仍在一刻不停地搬动着圆盘。恩，当然这个传说并不可信，如今汉诺塔更多的是作为一个玩具存在。Gardon就收到了一个汉诺塔玩具作为生日礼物。Gardon是个怕麻烦的人（恩，就是爱偷懒的人），很显然将64个圆盘逐一搬动直到所有的盘子都到达第三个柱子上很困难，所以Gardon决定作个小弊，他又找来了一根一模一样的柱子，通过这个柱子来更快的把所有的盘子移到第三个柱子上。下面的问题就是：当Gardon在一次游戏中使用了N个盘子时，他需要多少次移动才能把他们都移到第三个柱子上？很显然，在没有第四个柱子时，问题的解是2^N-1，但现在有了这个柱子的帮助，又该是多少呢？

**输入格式:**
包含多组数据，每个数据一行，是盘子的数目N(1<=N<=64)。

**输出格式:**
对于每组数据，输出一个数，到达目标需要的最少的移动数。

**解题思路:**
应将此题分为3个步骤：
	1.将n个盘子分为1~i（ i为1—N之间的数）和i~n两部分,并将小的部分移动到另一根柱子上
	2.将大的部分从第一根柱子移动到最后一根柱子
	3.将小的部分移动到最后一根柱子
第一步和第三步都是i个盘子进行一次汉诺塔 || 移动的次数，第二部是n-i个盘子移动一次传统汉诺塔的次数（题目已给出，为2^N-1），所以递推公式为：
<center>**a[n] = 2*a[i] + 2^(n - i) - 1**</center>
在程序中遍历i的值，并将求得的答案取最小存入缓存即可。详见代码。

**c++ 代码：**

	#include<iostream>
	#include<math.h>
	typedef unsigned long long ull;
	using namespace std;
	ull dp[10001];
	void cal(int a) {
	    ull min = 1;
	    for (int i = 1; i < a; i++) {//遍历i值
	        ull ans = 2 * dp[i] + pow(2, a - i) - 1;
	        if (min == 1)min = ans;
	        else min = min < ans ? min : ans;
	    }
	    dp[a] = min;
	}
	int main() {
	    dp[0] = 0;//这个值可以随便填
	    dp[1] = 1;
	    int temp = 1;//记录已经计算的盘子数
	    int t;
	    while (scanf("%d", &t) != EOF) {
	        //如果需要的值没有进行计算，则先计算
	        if (temp < t) for (int i = temp; i <= t; i++) cal(i);
	        cout << dp[t] << endl;
	    }
	    return 0;
	}

---------------------

#### 7.5 简单的归并

如题所诉，将已经拆分的单元按题目要求合并即可。

**题目详情:**
已知数组A和B各有m、n个元素，且元素按值非递减排列，现要求把A和B归并为一个新的数组C，且C中的数据元素仍然按值非递减排列。 例如，若A=(3，5，8，11)，B=(2，6，8，9，11，15，20)， 则C=(2，3，5，6，8，8，9，11，11，15，20)

**输入格式:**
首先输入一个正整数T，表示测试数据的组数，然后是T组测试数据。 每组测试数据输入两行，其中第一行首先输入A的元素个数m（1≤m≤100），然后输入m个元素。第2行首先输入B的元素个数n（1≤n≤100），然后输入n个元素。

**输出格式:**
对于每组测试数据。分别输出将A、B合并后的数组C的全部元素。输出的元素之间以一个空格分隔（最后一个数据之后没有空格）。

**解题思路：**
进行归并操作，使用指针或int记录位置，将两列已排序数字进行比较，输出较小的那个数并将那个数的指针后移一位。当两列中的某一列已经全部完成，将另一列的数逐个输出即可。具体内容见代码注释。

**c++代码：**

	#include<iostream>
	using namespace std;
	int main() {
	    int t;
	    cin >> t;
	    while (t--) {
	        int a[10001], b[10001];
	        int a1, b1/*数组长度*/, aa = 0, bb = 0/*数组下标*/;
	        cin >> a1;
	        for (int i = 0; i < a1; i++) cin >> a[i];
	        cin >> b1;
	        for (int i = 0; i < b1; i++) cin >> b[i];
	        while (aa < a1 && bb < b1) /*两组数进行比较*/
	        cout << (a[aa] < b[bb] ? a[aa++] : b[bb++]) << " ";
	        /*其中一组全部输出后*/
	        if (aa == a1) while (bb < b1) cout << b[bb++] << " ";
	        if (bb == b1) while (aa < a1) cout << a[aa++] << " ";
	        cout << endl;
	    }
	}

---------------------

#### 7.6 字符串全排列

next_permutation(arr, arr+size) 函数是c++中 algorithm 库中的函数。

-参数解释：arr为数组，size为数组长度
-效果：将数组变为下一个 *较大值* 数组
-返回值：当有下一个 *较大值* 返回1，否则返回0，为int类型

较大值的例子：3 2 1，只有上一个较小值，没有下一个较大值。1 2 3只有下一个较大值，没有上一个较小值。2 1 3 的上一个较小值为 1 3 2，下一个较大值为 2 3 1.

**题目详情：**
给定一个全由小写字母构成的字符串，求它的全排列，按照字典序从小到大输出。

**输入格式:**
一行，一个字符串，长度不大于8。

**输出格式:**
输出所有全排列，每行一种排列形式，字典序从小到大。

**解题思路：**
将函数的返回值作为循环的条件即可。

**c++代码：**

	#include<iostream>
	#include<algorithm>
	using namespace std;
	
	int main() {
	    char a[9];
	    cin >> a;
	    int n = strlen(a);
	    sort(a, a + n); 
	    do{
	        for (int i = 0; i < n; i++) cout << a[i];
	        cout << endl;
	    } while (next_permutation(a, a + n));//先使最小字典序数组输出
	}

---------------------

#### 7.7 逆序对

原理是排序问题，详见解题思路。

**题目详情：**
求逆序对。

**输入格式:**
第一行是一个整数n，（n<=1000,000）表示输入序列的长度，接下来一行是n个整数(每个数的绝对值小于109)。

**输出格式:**
一个数，表示逆序对个数(逆序即任意一对数前面的数比后面的数大即为一对逆序对)。

**解题思路：**
排序的过程实际上就是将逆序对交换，当序列中没有逆序对时，排序也就完成了。所以此题选用一种时间复杂度较低的排序方法进行稍微修改即可。

代码示例使用的是归并排序。归并过程中，前组的数据大于后组时就证明前组这个数后面的数都跟后组的这个数据构成逆序对。

**c++代码：**

	#include<iostream>
	using namespace std;
	//根据菜鸟教程提供函数改编
	typedef unsigned long long ull;
	ull ans = 0;//逆序对个数
	template<typename T> //函数模板
	void merge_sort(T arr[], int len) {
	    T* a = arr;
	    T* b = new T[len];//申请内存
	    //划分排序区间（一次排几个）
	    for (int seg = 1; seg < len; seg += seg) {
	        //排序起始位置
	        for (int start = 0; start < len; start += seg + seg) {
	            int low = start, mid = min(start + seg, len),
	                high = min(start + seg + seg, len);//将区间分为两段
	            int k = low;//下标
	            int start1 = low, end1 = mid;//前段
	            int start2 = mid, end2 = high;//后段
	            while (start1 < end1 && start2 < end2){//开始排序，从小到大
	                //将小的数字插在前面
	                if (a[start1] <= a[start2]) b[k++] = a[start1++];
	                else {//产生逆序对的消除，计算此次消除逆序对的个数
	                    b[k++] = a[start2++];
	                    ans += end1 - start1;//逆序对个数增加量
	                }
	            }
	            //将前/后段剩余数据顺序写入
	            while (start1 < end1)
	                b[k++] = a[start1++];
	            while (start2 < end2)
	                b[k++] = a[start2++];
	        }
	        //将最新排序的指针换为a，另一区域换为b
	        T* temp = a;
	        a = b;
	        b = temp;
	    }
	    //最后将arr段替换为排好的顺序，并使a指向它
	    if (a != arr) {
	        for (int i = 0; i < len; i++)
	            b[i] = a[i];
	        b = a;
	    }
	    //清除b的内存
	    delete[] b;
	}
	
	int main() {
	    int a;
	    int an[1000001];
	    cin >> a;
	    for (int i = 0; i < a; i++) cin >> an[i];
	    merge_sort(an, a);//归并排序
	    //for (int i = 0; i < a; i++) cout << an[i] << " ";
	    cout << ans;
	}

#### 7.8 二分查找

顾名思义，就是从中间向两边查找的算法。每一次2分可将区间缩减一半直到找到答案。

**题目详情：**
请实现有重复数字的有序数组的二分查找。输出在数组中第一个大于等于查找值的位置，如果数组中不存在这样的数，则输出数组长度加一。

**输入格式:**
输入第一行有两个数，第一个数为数组长度n（≤10^6），第二个数为需要查找的数。
接下来有n个整数，以空格或换行符分隔。

**输出格式:**
输出待查找的数的位置。

**解题思路：**
由于是有序数组，每一次将区间2分，都可以通过比较中间数判断所找的数在左半还是右半。找到相同的数的时候并不完全是此题的答案，应该继续2分或者向前逐个查找。使用两个指针或下标表示区间的头和尾，在移动头和尾缩小区间即可。

**c++代码：**

	#include <iostream>
	using namespace std;
	int main(){
	    int a,b;
	    int aa[1000001];
	    cin>>a>>b;
	    for(int i=1;i<=a;i++){
	        cin>>aa[i];
	    }
	    int fir=1,las=a;//头和尾
	    while(fir<=las){
	        int temp=(fir+las)/2;//中间
	        if(aa[temp]>=b) {
	            for(int i=temp-1;i>=1;i--){
	                if(aa[i]>=b) temp=min(temp,i);
	            }
	            cout<<temp<<endl;
	            break;
	        }
	        else fir=temp+1;
	    }
	    if(fir>las) cout<<a+1<<endl;
	    return 0;
	}