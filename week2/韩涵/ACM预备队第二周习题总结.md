# ACM预备队第二周习题总结
**BY 韩涵**

在week2的习题中，对递归、分治、归并进行了学习。
### 1.递归

------------


程序调用自身的编程技巧称为递归（ recursion），递归就是自己调用自己。递归算法通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，从而简化问题的复杂性。

**递归算法一般用于解决三类问题：**

1. 数据的定义是按递归定义的。（Fibonacci函数）
2. 问题解法按递归算法实现。这类问题虽则本身没有明显的递归结构，但用递归求解比迭代求解更简单，如Hanoi问题。
3. 数据的结构形式是按递归定义的。如二叉树、广义表等，由于结构本身固有的递归特性，则它们的操作可递归地描述。

**递归的缺点：**
递归算法解题相对常用的算法如普通循环等，运行效率较低。因此，应该尽量避免使用递归，除非没有更好的算法或者某种特定情况，递归更为适合的时候。在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储。递归次数过多容易造成栈溢出等。

#### 7.1 汉诺塔问题
给定一个由n个圆盘组成的塔，这些圆盘按照大小递减的方式套在第一根桩柱上。现要将整个塔移动到另一根桩柱上，每次只能移动一个圆盘，且较大的圆盘在移动过程中不能放置在较小的圆盘上面。

**输入格式:**
输入由四行： 第一行是圆盘数量n(1<=n<=10); 第二行到第四行分别是三根桩柱的名字(字符串)，n个盘子套在第一根桩柱上。

**输出格式:**
输出移动步骤，每行输出一步。

**解题思路：**
汉诺塔问题是最典型的递归问题。将n个圆盘从第一根桩柱上移动到第三根桩柱上，等价于将上面n-1个圆盘从第一根桩柱上移动到第二根桩柱上，再将第n个圆盘从第一根桩柱上移动到第三根桩柱上，最后将上面n-1个圆盘从第二根桩柱上移动到第三根桩柱上。详细的解释请看代码中注释。
###### Python 代码：
    def hanoi(a, b, c, d):  # a，b，c分别为一，二，三根柱子
        if d > 1:  # 当 d = 1时就只有一个圆盘，不需要在进行递归
            hanoi(a, c, b, d - 1)  # 将n-1个圆盘从a移动到b
        print(a + "->" + c)
        if d > 1:  # 同理
            hanoi(b, a, c, d - 1)  # 将n-1个圆盘从b移动到c
    
    
    def week2_1():
        n = int(input(""))
        name = [input(""), input(""), input("")]
        hanoi(name[0], name[1], name[2], n)
    
    
    if __name__ == '__main__':
        week2_1()
接下来用c++进行演示（不在进行解释）
###### c++代码：
    #include<iostream>
    using namespace std;
    void han(string a,string b,string c,int d) {
    	if (d > 1)han(a, c, b, d - 1);
    	cout << a << "->" << c << endl;
    	if (d > 1)han(b, a, c, d - 1);
    }
    int main() {
    	int n;
    	cin >> n;
    	string name[3];
    	for (int i = 0; i < 3; i++) cin >> name[i];
    	han(name[0], name[1], name[2], n);
    }

### 2.分治与归并

------------
分治，字义“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，子问题可以简单的直接求解，原问题的解即子问题的解的合并。分治法的基本思想：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。

**采用分治法解决的问题特征：**
1. 问题的规模缩小到一定的规模就可以较容易地解决。
2. 问题可以分解为若干个规模较小的模式相同的子问题，即该问题具有最优子结构性质。
3. 合并问题分解出的子问题的解可以得到问题的解。
4. 问题所分解出的各个子问题之间是独立的，即子问题之间不存在公共的子问题。

归并，指合并；合在一起。语出《后汉书·广陵思王荆传》：“若归并二国之众，可聚百万。”顾名思义，归并排序是将序列拆分为小块进行排序在合并的算法。是分治的一个非常典型的应用。

**归并排序可以分为五个步骤：**
1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；

2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置；

3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；

4. 重复步骤 3 直到某一指针达到序列尾；

5. 将另一序列剩下的所有元素直接复制到合并序列尾。
![归并排序动态图解--来自菜鸟教程](https://www.runoob.com/wp-content/uploads/2019/03/mergeSort.gif)

归并排序的时间复杂度为O(n*logn)，可以加快排序速度，但是需要申请额外的空间。

#####7.3 归并排序
给定你一个长度为 n 的整数数列。请你使用归并排序对这个数列按照从小到大进行排序。并将排好序的数列按顺序输出。

**输入格式:**
输入共两行，第一行包含整数 n(1≤n≤100000)。第二行包含 n 个整数（所有整数均在 1∼10^9 范围内），表示整个数列。

**输出格式:**
输出共一行，包含 n 个整数，表示排好序的数列。

**解题思路：**
根据归并排序的五个步骤执行即可
参考链接：https://www.runoob.com/w3cnote/merge-sort.html
######c++代码：
	#include<iostream>
	using namespace std;
	
	//根据菜鸟教程提供函数改编
	template<typename T> //函数模板
	void merge_sort(T arr[], int len) {
	    T* a = arr;
	    T* b = new T[len];//申请内存
	    //划分排序区间（一次排几个）
	    for (int seg = 1; seg < len; seg += seg) {
	    //排序起始位置
	        for (int start = 0; start < len; start += seg + seg) {
	            int low = start, mid = min(start + seg, len), 
	                high = min(start + seg + seg, len);//将区间分为两段
	            int k = low;//下标
	            int start1 = low, end1 = mid;//前段
	            int start2 = mid, end2 = high;//后段
	            while (start1 < end1 && start2 < end2)//开始排序，从小到大
	                b[k++] = //将两段中小的插在前面
	                   a[start1] < a[start2] ? a[start1++] : a[start2++];
	            //将前/后段剩余数据顺序写入
	            while (start1 < end1)
	                b[k++] = a[start1++];
	            while (start2 < end2)
	                b[k++] = a[start2++];
	        }
	        //将最新排序的指针换为a，另一区域换为b
	        T* temp = a;
	        a = b;
	        b = temp;
	    }
	    //最后将arr段替换为排好的顺序，并使a指向它
	    if (a != arr) {
	        for (int i = 0; i < len; i++)
	            b[i] = a[i];
	        b = a;
	    }
	    //清除b的内存
	    delete[] b;
	}
	
	int main() {
		int a;
	    long long int ans[100001];
		cin >> a;
		for (int i = 0; i < a; i++) cin >> ans[i];
	    merge_sort(ans, a);//归并排序
	    for (int i = 0; i < a; i++) cout << ans[i] <<" ";
	}
###3.   7.2 分而治之

------------

分而治之，各个击破是兵家常用的策略之一。在战争中，我们希望首先攻下敌方的部分城市，使其剩余的城市变成孤立无援，然后再分头各个击破。为此参谋部提供了若干打击方案。本题就请你编写程序，判断每个方案的可行性。

**输入格式：**
输入在第一行给出两个正整数 N 和 M（均不超过10 000），分别为敌方城市个数（于是默认城市从 1 到 N 编号）和连接两城市的通路条数。随后 M 行，每行给出一条通路所连接的两个城市的编号，其间以一个空格分隔。在城市信息之后给出参谋部的系列方案，即一个正整数 K （≤ 100）和随后的 K 行方案，每行按以下格式给出：
Np v[1] v[2] ... v[Np]
其中 Np 是该方案中计划攻下的城市数量，后面的系列 v[i] 是计划攻下的城市编号。

**输出格式：**
对每一套方案，如果可行就输出YES，否则输出NO。

**解题思路：**
将输入方案带入通道两端进行检测，如果有通道的两端没有在方案中出现，此计划则尚存通路不可行，没有则反之。

此题如果有过多的循环或者递归调用，就会出现超时的问题，想办发减少for循环是关键。示例（我的代码）采用的是使用find函数进行搜索以减少循环次数。

######c++代码：
	#include<iostream>
	#include<set>
	using namespace std;
	int city[10001][2] = { 0 };
	set<int>test;
	bool judge(int n) {
	    bool flag = true;
	    for (int i = 0; i < n; i++) {
	        if (test.find(city[i][0]) == test.end() && 
	            test.find(city[i][1]) == test.end()) {
	            flag = false;
	            break;
	        } 
	    }
	    test.clear();
	    return flag;
	}
	int main() {
	    int n, m, p;
	    cin >> n >> m;
	    for (int i = 0; i < m; i++) cin >> city[i][0] >> city[i][1];
	    int a;
	    cin >> a;
	    while (a--) {
	        int t;
	        cin >> t;
	        for (int i = 0; i < t; i++) {
	            cin >> p;
	            test.insert(p);
	        }
	        if (judge(m)) cout << "YES" << endl;
	        else cout << "NO" << endl;
	    }
	}




