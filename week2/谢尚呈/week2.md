# 河内塔

从来不敢碰的一道题……但是明白现实中的河内塔解法

·只有一个圆盘时，直接移动到目标柱子上

·有两个圆盘时，第一个先移动到非目标的另一根柱子上，第二个移动到目标柱子上，第一个再移动到目标柱子上

·有多于三个圆盘时，重复上例，只不过每次步骤的目标柱子不一定是既定整个过程的目标柱子

但是具体实现上，还是参照了之前在算法书上看到的写法

# 分而治之

这道题目的城市总数没有意义，基本思路是检查这个方案实行完后还有没有道路剩下。

·使用结构体`road`，分为起点城市`int s;`和终点城市`int e;`，还有道路仍然有效的标记`bool use;`，创建`road way[10001];`当计划中出现的城市与i号道路`way[i].s`或`way[i].e`相同时`way[i].use=false;`，但是出现了未解明的数组越界

·使用链表，链表节点和`road`相似，只是把写false的步骤改为删除链表节点（每次核验方案的时候复制一份链表），出现了未解明的方案可行却仍然有节点没有被删除的情况

最终参照CSDN的解法。由于不了解STL（先前遇到此类问题都是自己写个链表过了的），还在学习该解法中。

# 归并排序

分治算法的经典问题。

归并排序中，需要完成一下操作：

·若是既定序列只包含一个元素，不需要操作

·若是既定序列包含两个元素，为了节省时间直接排序这两个元素，按照排序规则交换或不交换这两个元素在原数组中的位置

·将既定序列左右等分开

·归并排序左序列

·归并排序右序列

·`new`一个长度等于既定序列长度的数组，不断从左序列与右序列中捡符合排序规则的数加入这个数组。当左序列已用尽时，这个数组的剩下部分填充右序列的剩下部分，反之亦然

·将需要排序的原数组各个值赋为新数组相同位置上的值

·别忘了`delete`新数组