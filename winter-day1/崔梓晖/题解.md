1.看到题目要求满足单点修改和区间查询，想到采用树状数组或者线段树来完成操作。树状数组较为简洁好写，我推荐采用树状数组。





2.采用容器vector：

1.插入操作：a.insert(a.begin()+pos+1,s[i]);

2.删除操作：a.erase(a.begin()+pos);

3.注意记录光标的状态即可。





3.按照题意模拟





4.采用数组，对数组进行sort后，按照题意输出即可。







5，

注意点1.对括号进行匹配，可采用栈，也可手写：

2.输出未匹配括号个数为t+n。t为左括号剩余个数，n为右括号剩余个数;

3.输出匹配后结果：若右括号多余把多余右括号的个数从左边开始输出左括号，若左括号多余把多余左括号的个数从右边开始输出右括号。







6.直接暴力从前和从后扫一遍判断即可。







7.按照题意模拟：若为A，B，按照题意输出：若为括号中的数，采用栈将元素压入，最后依次取栈顶元素并弹出即可。







8.采用栈进行括号匹配，若为左括号，则将其压入栈中。若两括号匹配，将栈顶弹出即可。最后若栈为空则全匹配，否则不匹配。







9.这道题不会，参考了CSDN博客后得到以下思路：采用结构体struct gk
{
    string name;
    int begin;
    int end;
    int time;
}a[10001]; 

来维护顾客的名字,begintime,endtime.

同时采用map对字符串进行一个映射：

采用队列来对okline进行维护。

在读入后按照题意进行相对应的操作。

注意：1.当时间大于60时应按照60计算：

​         if(a[i].end>60)
​        {
​            a[i].end=60;
​        }

2，注意最后的输出格式要求：printf("%.1f",1.0*ans/n);







10.本题直接采用暴力的手段，因为数据范围N<100；所以不用担心TLE，双重循环：

第一层表示枚举平行铁轨的个数，然后引入maxx，在对于每节车厢进行枚举：

若小于maxx，更新maxx,并做标记。

最后输出ans即可。