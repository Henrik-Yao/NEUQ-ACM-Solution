动态区间求和：

​		先看数据范围，nq都小于十的六次方，假设q多一点很容易可以把暴力算法卡掉。这个时候我们就需要一个支持单点修改区间查询的数据结构来帮助我们维护这些数据。

​		树状数组也可以，线段树也可以，树状数组可能更简单一点，但我还是喜欢用更强力的线段树。线段树可以帮助我们实现区间修改（当然可以实现单点修改），区间查询。

​		然后背个板子。没什么好说的就是背下来板子。



小明打字：

​		这道题一度困扰了我很久，因为我还是对vector的理解只限于加边，这道题如果用数组嗯模拟的话是很难模拟的，你需要考虑移动光标对后面的字符带来的影响，但如果在vector的基础上应用insert和erase两个函数就可以轻松的实现对移动光标和输入模式切换的处理。

​		输入就相当于在末尾的位置插入一个新值，移动光标相当于移动处理的位置，设置一个变量用于储存处理的位置，每次删除或者插入都往变量指向的位置操作即可。

​		n个数中有n+1个空隙，a.begin()相当于第一个空隙，a.end()相当于最后一个空隙。

​		a.insert(a.begin()+i,shuzhi):在第i+1个空隙也就是第i个数的右边的位置插入一个shuzhi

​		a.erase(a.begin()+i):在第i+1个空隙的右边也就是第i个数的右边删去一个数，即删去第i+1个数

​		更多vector用法：https://blog.csdn.net/lwgkzl/article/details/82110068

特殊约瑟夫问题：

​		可以用数组来模拟这个环，取一个变量flag来标记报数报到哪里，要注意到的是，每次出列一个人后，报1的是这个已经出列的人的下一个人，然后反向报数。还要注意的是因为第一个人报1，第二个人报2，而这时flag+1，也就是说报数报到n，变量只需要移动n-1次。还有一点要注意，用数组模拟不太方便的地方在于每次遍历有可能遍历到已经出列的人，所以每次移动都要记得跳过出列的人。



程序设计综合实践 1.4：

​		我对链表其实不太了解，大多数情况中都可以用数组模拟出来，用数组模拟链表，一次输入一行字符，从中筛选出每个数字并sort排序，再在其中筛选出奇数元素与偶数元素。



括号匹配：

​		这道题是一道比较经典的栈的题，对于每个输入，如果是左括号则top--，是右括号则top++，在top不断变化的过程中若top小于零则需将其补回0，并将需要添加的左括号的个数加一，处理到最后若top大于0则仍需将其补回0，top是多少则需要添加的右括号的个数就是多少。若需要添加的括号个数都为0则该序列匹配，若不为0则先输出需要添加的左括号，再将原串输出，再输出需要添加的右括号。



字符串对称：

​		我对顺序栈也不够了解，对于一个字符串，遍历i从0到len-1，若s[i]恒等于s[len-i-1],则这个字符串对称。



魔王语言解释：

​		对题目进行简化得每个B对应一个字符串，每个括号内的字符串对应一个字符串，逐个字符处理字符串，若该字符为B则直接输出对应的字符串，若找到左括号就从左括号开始找直到找到右括号，在括号内的每两个字符之间插入一个第一个字符，注意字符串的顺序是反着的。



括号配对：

​		这道题类似于前一道括号匹配，给每个括号对应一个值，忽略除了括号以外的符号，若字符为某个左括号，则记录括号种类并top++，若字符为某个右括号且对应的值与top位置的左括号的值相同则top--。最后若top==0且中间没有出现不匹配的情况则该字符串匹配，否则不匹配。



银行排队问题之单窗口“夹塞”版:

​		这道题也是一道大模拟。对于每个朋友圈，可以考虑用map将同一个朋友圈中的名字映射到同一个数字上去，这样就可以通过判断两个人名字对应的数字是否一样来快速的判断两个人是否为朋友。

​		然后用结构体来存储一个人的名字，来的时间与办事所需时间，用pan数组来控制每个人都只计算一次。i从1遍历到n，对于每个人，若当前时间未到他来的时间就将当前时间调到来的时间，等待时间为当前时间减去他来的时间。然后再将当前时间加上办事所需时间，然后从i+1往下找，若下个人也符合要求，则先计算他的等待时间，相当于让其插队。可以证明的是，若a是b的朋友，且b是c的朋友，则a和c也是朋友。所以只需要要求这个人来的时间比这个朋友圈第一个人来的时间迟，比当前时间早即可（因为若比当前时间迟则上一个人已经走了，这个人虽然和上一个人是朋友但还是得重新排队）

​		**又一个血的教训：**记得要给每个人名字的mp赋初值，不然不在朋友圈里的人的mp值都为0，相当于不在朋友圈里的人又构成一个朋友圈，这显然是不对的。



列车车厢重排：

​		这道题要求将一段1到n的重排列抽成若干个降序的串，即每个串里的数字必须是降序的，且序号的顺序也不能乱。对于每次新进来的车厢，遍历已经有的轨道，如果能停放，即车厢编号小于轨道最后面的车厢的编号，就将其放进去，**如果对于所有轨道都不能放进去**，则需要新开辟一个轨道并放进去，如果该车厢标号为一则标记车厢进入的轨道，最后将该轨道的车厢编号全部输出并输出轨道总数。

​		当然对于选择方案进行贪心优化也是可以的，可以优先选择每个轨道最后面车厢编号与新进来的车厢编号差值最小的轨道放进去，这样影响到后面车厢的选择的可能性最小。

​		还有就是一定要区分加粗部分与贪心部分，我把这两个条件写在一起，然后爆调一下午没调出来，**血的教训**啊大伙。

