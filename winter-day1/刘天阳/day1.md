**7-1 动态区间求和**

线段树 [〔manim | 算法 | 数据结构〕 完全理解并深入应用树状数组 | 支持多种动态维护区间操作_哔哩哔哩](https://www.bilibili.com/video/BV1pE41197Qj)

**7-2 小明打字**

参考 [题解 CPPU第五届“精武杯”计算机算法设计网络赛 | 我有昕想法 | Peter_Matthew的博客 (zhangkai.xin)](https://www.zhangkai.xin/blog/solution-cppu2021/)

设置一个指针，用string的insert和erase

**7-3 特殊约瑟夫问题**

约瑟夫问题 模拟做的

注意报数和位置变化的先后，先确定位置是合法的再报数

```cpp
while(t<m) 
{
	s--;    //位置变化
	if(!s) s+=n; //越界处理
	if(!vis[s]) t++; //最后报数
}
```

**7-4 程序设计综合实践 1.4**

~~sort~~

**7-5 括号匹配**

用栈匹配么，我用了两次，从前往后一次，从后往前一次，左括号和右括号多余的就会留在栈里面，然后就能配对

**7-6 字符串对称**

回文判断

**7-7 魔王语言解释**

模拟

**7-8 括号配对**

利用栈进行配对

```cpp
stack<char>q;
q.pop(); // 弹出最上面的元素，但不会访问
q.top(); // 访问最上面的元素，但不会弹出
q.push(c); // 将c压入栈中
```

**7-9 银行排队问题之单窗口“夹塞”版**

​		最开始我想的是每个人都单独判断，看看前面又没有可以插队的人，最后搞得时间一只有问题。后面上网看了别人的方法，[数据结构与算法题目集7-48——银行排队问题之单窗口“夹塞”版_清风阁-CSDN博客_数据结构银行排队问题](https://blog.csdn.net/qq_41231926/article/details/84943906)。

​		发现他是通过一个人解决一个圈子的人的排队问题，就是有一个人去排队，就把他圈子里面的人全部判断一遍，这样的话时间更好计算。

**7-10 列车车厢重排**

贪心

参考[拦截导弹（最长上升子序列+贪心详解）](https://blog.csdn.net/Jefferson__/article/details/119061488)

显然我们要让每一条轨道上的列车按照降序排列，对于每一辆列车，我们有两种选择：

 1. 找前面与他的序号相差最小的列车，接上

 2. 没有合适的列车，自己开辟一列

    ​		如果想要最少的列数，那么就要按照上述排列，我们设g[i表示每列结尾列车的序号，我们可以发现，g [ ] 一定是单调递增的,也就是说，新的轨道结尾序号肯定大于以前的，因为每次都是因为旧的结尾序号都太小而开辟新的车道。

    ​	序列只需开个vector用来记录即可

```cpp
	//核心代码
    //cnt表示列车道的个数
    int cnt = 0;
    for(int i = 0; i < n; i ++ ){
        int k = 0;   // 这里用k和cnt计数的技巧非常有用
        while(k < cnt && g[k] < q[i])   k ++ ;
        g[k] = q[i];
        if(k >= cnt) cnt ++ ;
    }

    cout << cnt << endl;
```

