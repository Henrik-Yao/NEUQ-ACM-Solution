# Day 3 题解
## 7-1 图的创建 
自定义一个结构体存储a,b,w，随后利用`sort`+一元谓词对编号进行排序，最后按格式输出即可
* * * 
## 7-2 图的删边操作
 在上一题的基础上加入删除操作，使用`find_if`+一元谓词找出对应边，`erase`掉即可
* * * 
## 7-3 递增子序列
递归搜索所有可能组合，使用数据类型`set<stack<int>>`来避免冲突
* * * 
## 7-4 岛屿数量 
一道非常典型的图的连通块题目，注意边界条件返回即可
* * *
## 7-5 繁忙的都市 
最小生成树问题，使用Kruskal算法解决，其中运用到并查集知识  
并查集核心代码为：`int find(int x) { return p[x] == x ? x : p[x] = find(p[x]); }`  
注意求的是边权的最大值
* * *
## 7-6 最小支撑树 
与上一题一样，同样是要找最小生成树，应用Kruskal算法。  
需要注意的是当连通块不为1时，不存在最小生成树
* * * 
## 7-7 特殊最小成本修路 
同样是最小生成树问题，但是这道题增加了条件：某个特殊的镇不能连接两条以上的道路。翻译一下，就是这个顶点的并查集不超过两个。  
其次，只需不在同一集合的两个代表元的合并次数达到n-1，即满足条件
* * *
## 7-8 排列论文 
这道题采用的是拓扑排序的思想。需要用到Kahn的算法中的入度的思想：若队列中某一时刻同时有两个及以上的入度为0的端点的话，在保证DAG的情况下，至少有两个拓扑序；若始终只有一个，则有唯一的拓扑序