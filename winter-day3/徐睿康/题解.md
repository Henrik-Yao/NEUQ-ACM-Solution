图的创建：

​		其实就是一个数组没法存的一个图的存储，可以使用动态数组即vector进行存储，用pair将另一个点与权值存在一起。

​		还有一个点要注意的就是题目要求一个点引出的多条边要按照另一个点递增排列，可以在输出时将vec[i]进行sort，即sort（vec[i] .begin(),vec[i].end()），同样在括号内放的是它的地址。



图的删边操作：

​		基本和上题相同，就是加了一步操作，要将一定的边删除。我们可以遍历找出我们要删去的边，然后用erase函数将其删去，erase用法与小明打字一题中erase用法相同，基本可以类比到有[i]的情形里。



递增子序列：

​		这道题要求找出原数组中所有不同的递增子序列的个数。我们可以通过搜索进行查找，关键的一点在于如何将搜到的不同序列进行去重。这里有不同的去重方法，可以用set数据结构的特点进行去重，可以将其转化为字符串然后用map哈希标记进行去重，这里我使用的是最朴素的数组，即将所有找到的序列用数组存起来，每次找到新序列时都将已知的全部找一遍，没有找到相同的再将其存起来。虽然时间复杂度较高，但这道题是允许这样做的。

​		这道题还有一个坑点在于，它的值有可能为负数，这就要求我们dfs时的初值必须很小小到能小于数据范围以内所有的负数

​		**交题时记得注释调试**



岛屿数量：

​		这道题是比较经典的bfs例题，也是不断地用bfs将一个岛屿里的所有位置都标记掉，再遍历所有点，能bfs就bfs，每次bfs时计个数就可以了。



繁忙的都市：

​		这道题属于最小生成树的模板题，他要求我们用权值尽可能小的边将整个图联通，相当于只用n-1条边联通整个图，也相当于将其练成一棵树。最小生成树有两种做法，一种叫kruscal，一种叫prim，前者比较便于理解与操作，所以就以前者为例。

​		我们可以用结构体存下所有边的信息，然后根据边权进行排序，优先使用边权小的边。这里也要用到并查集的知识，排序后遍历所有边，如果两个节点没有相同的祖先，即两个节点并不联通，就进行加边，同时将两个节点的父亲改为同一个人。这样在进行n-1次加边操作后一定能联通整个图，此时用的所有边的边权也一定是最小的。如果遍历完所有边仍没有完成n-1次加边，则说明这个图的最小生成树不存在。这里题目要求输出生成树中边权最大的边的权值，我们在加边过程中加以记录就可以了。



最小支撑树：

​		这道题同上题基本相同，不同点在于需要对生成树的存在进行判断，还有输出生成树权值之和，同样在加边过程中进行计算即可。



特殊最小成本修路：

​		这道题其实比较复杂，具体可以参考 [POJ 1639 Picnic Planning (k度限制最小生成树)_yunyouxi0's blog-CSDN博客](https://blog.csdn.net/Yunyouxi/article/details/39457457?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-1-39457457.pc_agg_new_rank&utm_term=度限制最小生成树&spm=1000.2123.3001.4430)  ，它需要将除了特殊点之外的所有连通块分别求一个最小生成树，再在特殊点与许多最小生成树之间加边，然后再遍历特殊点的所有出边，考虑是否要断掉原树的一条边再加上一条更优的边，代码长度在两百行左右，比较困难。（我也没学会）

​		但这道题的数据比较弱，弱到什么程度呢，当找到与特殊点相连的边时不管三七二十一直接连，如果连够两条直接放弃，错误的思路却可以得到正确的答案。

​		还要注意一个点，就是这里点的**编号是0到n-1**，因为是多组输入，初始化时不要处理错了。（说的就是我）



排列论文：

​		这道题其实是一道拓扑排序的模板题，它要求遍历有向图里的点时该点的所有前置点，即有边从前置点指向该点时，都必须被遍历过，这样我们就可以得到一个或多个由点构成的序列。

​		具体需要用一个数组存放入度，当一条边由a指向b时，b点的入度加1。这样，图上所有入度为0的点就都可以是我们遍历的起点。我们可以使用队列进行遍历，先将所有起点加入队列，然后每次取出一个点，将其所有的出边指向的点的入度-1，若此时该点入度为0，则将其入队。不断循环即可完成遍历。

​		在入队时可以进行计数，若最后计数不为n则说明该图不存在拓扑序，在任何时候，若队列里的元素大于1，则这几个元素就可以在拓扑序中互相调换位置，即存在多种拓扑序，若上述两种情况都不存在则说明拓扑序有且仅有一种。