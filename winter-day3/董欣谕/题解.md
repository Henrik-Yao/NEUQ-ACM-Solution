1、图的创建

这题多种存图方法均可使用，我使用的是链式前向星。

在输出时注意没有边的点跳过即可。

2、图的删边操作

为做题方便，我使用了二维map，通过erase函数实现删边操作。

3、递增子序列

一看数据范围n最大只有15，直接来一发爆搜

定义一个map<string,int>来存储状态。

将形成的子序列转化为字符串形式（在两个数之间加“，”）作为参数，如果当前轮次选取数字个数大于等于2则用map存储该序列。最后输出map.size()即可。

4、岛屿数量

dfs求图的连通块即可。

5、繁忙的都市

最小生成树模板的变形，将求最小花费改成了求树上的最大边权，方法类似。

6、最小支撑树

最小生成书的模板题。

7、特殊最小成本修路

这道题本该是一道挺难的题，但奈何数据实在太水，我钻空子过了。

标准做法应为：

首先，去掉V节点，无向图可能会分成若干个连通块，可以用dfs划分出图的每个连通块，设连通块共有T个，若T>2，则本题无解。

对于每个连通块，在这个连通块内部求出它的最小生成树，然后从连通块里选出一个节点P与V节点相连，其中无向边（1，p）的权值尽量小。

此时，我们已经得到了原无向图的一棵生成树，V号节点的度数为T，我们还可以尝试改动2-T条边，让答案更优。

考虑无向图中从节点V出发的每条边（1，x），边权为z。如果（1，x）还不在当前的生成树中，那么继续找到当前生成树中从x到1的路径上权值最大的边（u，v），边权为w。求出使得w-z最大的点x0.若x0对应的w0-z0>0，则从树中删掉边（u0，v0），加入边（1，x0），答案就会减小w0-z0.

重复上一步2-T次，或者直到w0-z0<=0，就得到了题目所求的最小生成树。

8、排列论文

拓扑排序的模板题。