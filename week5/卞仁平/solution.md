# 7-1

大致思路是用递归遍历第一个人的五代之内的祖先，对他们进行标记，然后对第二个人也用递归遍历，如果他的五代之内的祖先和第一个人的用重复，就跳出递归，返回一个标记值f

递归函数

```c++
void dfs(int z,int gen)
{
    if(gen>5||z==-1||z==0)//跳出递归的条件，超过五代，或者祖先不可考，或者祖先不在给出的数据范围之内
    return ;
    if(is[z])
    f=1;
    is[z]=1;//表明这个人出现过
    dfs(fu[z],gen+1);//遍历父辈
    dfs(mu[z],gen+1);//遍历母辈
    return ;
}
```

要注意的是，如果某个人的父母没有给出，但是自己要给他的父母输入性别

```c++
while(n--)
    {
        int ren;
        cin>>ren;
        cin>>sex[ren]>>fu[ren]>>mu[ren];
        sex[fu[ren]]='M';//父性别
        sex[mu[ren]]='F';//母性别
    }
```



# 7-2

四种情况

##### 1.偶数

由哥德巴赫最新猜想可知，偶数的情况直接输出2

##### 2.奇数

​	①质数直接输出1

​	②如果这个数-2为质数，就输出2

​	③除了上面的情况，输出3



# 7-3

有向图的遍历（深度优先）

```c++
void dfs(int x)
{
    if(is[x])//如果这个节点访问过，就返回
    return ;
    is[x]=1;//标记这个节点已经被访问过
    cout<<x<<" ";

    int end=n;
    for(int i=0;i<e;i++)
    {
        if(tu[i][0]==x&&!is[tu[i][1]])
        end=min(tu[i][1],end);//选择两个顶点中小的那个进行访问
    }
    if(end!=n)
    dfs(end);
}
```



# 7-4

个人理解近似为二维数组的遍历

整体思路就是用dfs遍历，如果这个点有山，就遍历他的上下左右

```c++
bool dfs(int x,int y)
{
    if(tu[x][y]==0)return 0;//不是山就返回
    if(tu[x][y])
    {
        tu[x][y]=0;//访问过就把他标记为0
        dfs(x+1,y);//遍历他的上下左右
        dfs(x-1,y);
        dfs(x,y+1);
        dfs(x,y-1);
        return 1;
    }
}                     
```



# 7-5

数组之内的反复横跳

要注意的是循环跳出条件，一开始我写的是个死循环

```c++
void dfs(int s)
{
    is[s]=1;//这个点来过，要是再来就是死循环了
    if(a[s]==0)//到达终点
    {
        f=1;
        return ;
    }
    int r=a[s]+s;
    int l=-a[s]+s;//定义左右可跳跃到的值
    if((r>=n||is[r])&&(l<0||is[l]))//跳出条件
    return ;
    if(r<n)
    dfs(r);
    else if(r>=0)
    dfs(l);
}
```

