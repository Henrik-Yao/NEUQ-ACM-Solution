### 7 - 1

---

找出第一个人的五代并且标记，再在遍历第二个人的五代，如果已经被标记则输出No,在储存的时候记得给父母标记上性别，也会有父母结婚的情况，否则会输出"Never Mind"。

---

### 7 - 2

---

数字上大于6的，如果是偶数则数字肯定是2，如果大于6且是素数，则是1，如果不是素数，由于即使奇数又是素数，且素数只有2是偶数，则先试试n - 2，如果是素数则表明是2个素数之和，如果不是素数，则需要先化成偶数可以先减去3变成欧式，偶数是两个素数的和，而n 则是两个素数和3的和即3个素数的和。

---

### 7 - 3

---

先把每一个顶点存在容器里，然后从零开始，标记，遍历容器里的每一个没有标记的顶点，递归。由于要求要先遍历比较小的顶点，可以先把边的大小进行排序后在输入。

---

### 7 - 4

---

遍历二维数组的每一个点，如果该点没有被标记，并且为1的话，总数加一，并且对该点进行标记，而且搜索周围的1，并且进行标记。最后输出即可。

---

遍历每一个1的部分

```
void p(int a,int b){
    v[a][b] = 1;
    for (int i = 0; i < 4; i++)
    {
    if(s[a+a1[i]][b+b1[i]]==1&&v[a+a1[i]][b+b1[i]]==0)p(a+a1[i],b+b1[i]);
    }
}
```



### 7 - 5

---

从开始点开始，标记点位，并且对该点所对数字的前后进行遍历，注意遍历的条件要没有标记而且不能超出数组的范围。

---

```
void f(int x){
    v[x] = 1;
    if(m[x]==0){
        t = 1;
        return;
    }
    if(x+m[x]<n&&v[x+m[x]]==0)f(x+m[x]);
    if(x-m[x]>=0&&v[x-m[x]]==0)f(x-m[x]);
}
```

