# 7-1 愿天下有情人都是失散多年的兄妹

呵呵。大家都知道五服以内不得通婚，即两个人最近的共同祖先如果在五代以内（即本人、父母、祖父母、曾祖父母、高祖父母）则不可通婚。本题就请你帮助一对有情人判断一下，他们究竟是否可以成婚？

### 输入格式：

输入第一行给出一个正整数`N`（2 ≤ `N` ≤104），随后`N`行，每行按以下格式给出一个人的信息：

```
本人ID 性别 父亲ID 母亲ID
```

其中`ID`是5位数字，每人不同；性别`M`代表男性、`F`代表女性。如果某人的父亲或母亲已经不可考，则相应的`ID`位置上标记为`-1`。

接下来给出一个正整数`K`，随后`K`行，每行给出一对有情人的`ID`，其间以空格分隔。

注意：题目保证两个人是同辈，每人只有一个性别，并且血缘关系网中没有乱伦或隔辈成婚的情况。

### 输出格式：

对每一对有情人，判断他们的关系是否可以通婚：如果两人是同性，输出`Never Mind`；如果是异性并且关系出了五服，输出`Yes`；如果异性关系未出五服，输出`No`。

### 输入样例：

```in
24
00001 M 01111 -1
00002 F 02222 03333
00003 M 02222 03333
00004 F 04444 03333
00005 M 04444 05555
00006 F 04444 05555
00007 F 06666 07777
00008 M 06666 07777
00009 M 00001 00002
00010 M 00003 00006
00011 F 00005 00007
00012 F 00008 08888
00013 F 00009 00011
00014 M 00010 09999
00015 M 00010 09999
00016 M 10000 00012
00017 F -1 00012
00018 F 11000 00013
00019 F 11100 00018
00020 F 00015 11110
00021 M 11100 00020
00022 M 00016 -1
00023 M 10012 00017
00024 M 00022 10013
9
00021 00024
00019 00024
00011 00012
00022 00018
00001 00004
00013 00016
00017 00015
00019 00021
00010 00011结尾无空行
```

### 输出样例：

```out
Never Mind
Yes
Never Mind
No
Yes
No
Yes
No
No结尾无空行
```

### 分析：

深搜加标记，先将男方的祖辈全部标记一遍，女方深搜时，若遇到有相同祖辈，递归结束，若五代以上都没出现，则标记不被使用。

这题有个坑，要根据子女的输入确定父母的性别，因为父母也是可以验证能否结婚的。

被坑了两个多小时....

```c++
#include <bits/stdc++.h>
using namespace std;
#define maxn 100000
int vis[maxn];
int n, k, lover1, lover2, flag;
int id, dad[maxn], mom[maxn];
char gender[maxn];

void dfs(int x, int t) {
	if (t > 5 || x == -1 || flag || x == 0)
		return ;
	if (vis[x])
		flag = 1;
	vis[x] = 1;
	dfs(dad[x], t + 1);
	dfs(mom[x], t + 1);
	return;
}

int main() {
	cin >> n;
	while (n--) {
		cin >> id >> gender[id] >> dad[id] >> mom[id];
		gender[dad[id]]='M';
		gender[mom[id]]='F';
	}
	cin >> k;
	while (k--) {
		cin >> lover1 >> lover2;
		if (gender[lover1] == gender[lover2]) {
			cout << "Never Mind" << endl;
			continue;
		}
		flag = 0;
		memset(vis, 0, sizeof vis);
		dfs(lover1, 1);
		dfs(lover2, 1);
		if (flag)
			cout << "No" << endl;
		else
			cout << "Yes" << endl;
	}
	return 0;
}
```



# 7-2 哥德巴赫最新猜想

X遇到一个关于素数的问题需要你这位大牛帮他解决。素数（prime number）又称质数。一个大于1的自然数，除了1和它本身外，不能整除以其他自然数，换句话说就是该数除了1和它本身以外不再有其他的因数，否则称为合数。哥德巴赫是德国数学家。出生于格奥尼格斯别尔格（现名加里宁城）。曾在英国牛津大学学习。原学法学，由于在欧洲各国访问期间结识了贝努利家族，所以对数学研究产生了兴趣。曾担任中学教师。1725年，到了俄国，同年被选为彼得堡科学院院士。1725年~1740年担任彼得堡科学院会议秘书。1742年，移居莫斯科，并在俄国外交部任职。1742年，哥德巴赫在教学中发现，每个不小于6的偶数都是两个素数之和。如6＝3＋3，14＝3＋11等等。公元1742年6月7日哥德巴赫写信给当时的大数学家欧拉，欧拉在6月30日给他的回信中说，他相信这个猜想是正确的，但他不能证明。叙述如此简单的问题，连欧拉这样首屈一指的数学家都不能证明，这个猜想便引起了许多数学家的注意。我们不需要你去证明哥德巴赫猜想。我们假设哥德巴赫猜想是正确的，一个不小于6的偶数，都是两个素数之和。例如14＝3＋11，也可以表示为14=7+7。现在的问题是给定一个正整数N，求N是最少几个素数的和。。

### 输入格式:

首先输入一个正整数N，代表测试数据的组数，接下来输入N个正整数，分别代表要处理的数，每组一个正整数满足在：6 ~ 1000000000 范围。。

### 输出格式:

输出将会有N行，每行对应一个数的歌德巴赫最新猜想这个数时候需要的最少素数个数。。

### 输入样例:

在这里给出一组输入。例如：

```in
2
9
11结尾无空行
```

### 输出样例:

在这里给出相应的输出。例如：

```out
2
1结尾无空行
```

### 分析：

这题比较简单，分析后可知

1.若为素数则输出1；

2.若为偶数，都是输出2，还有一种情况因为2时偶数又是素数，所以只要（x-2)也是素数那么也输出2；

3.剩余的奇数都输出3；

```c++
#include <bits/stdc++.h>
using namespace std;

int prime (int p) {
	for (int i = 2; i <= sqrt(p); i++) {
		if (p % i == 0)
			return 0;
	}
	return 1;
}

int main() {
	int n;
	cin >> n;
	for (int j = 1; j <= n; j++) {
		int x;
		cin >> x;
		if (prime(x) == 1)
			cout << 1 << endl;
		else if (x % 2 == 0 || prime(x - 2) == 1)
			cout << 2 << endl;
		else
			cout << 3 << endl;
	}
	return 0;

}
```

# 7-3 图深度优先遍历

编写程序对给定的有向图（不一定连通）进行深度优先遍历，图中包含n个顶点，编号为0至n-1。本题限定在深度优先遍历过程中，如果同时出现多个待访问的顶点，则优先选择编号最小的一个进行访问，以顶点0为遍历起点。

### 输入格式:

输入第一行为两个整数n和e，分别表示图的顶点数和边数，其中n不超过20000，e不超过50。接下来e行表示每条边的信息，每行为两个整数a、b，表示该边的端点编号，但各边并非按端点编号顺序排列。

### 输出格式:

输出为一行整数，每个整数后一个空格，即该有向图的深度优先遍历结点序列。

### 输入样例1:

```in
3 3
0 1
1 2
0 2结尾无空行
```

### 输出样例1:

```out
0 1 2 



结尾无空行
```

### 输入样例2:

```in
4 4
0 2
0 1
1 2
3 0结尾无空行
```

### 输出样例2:

```out
0 1 2 3 



结尾无空行
```

### 分析：

图不一定联通，所以还要一个for来清除剩余的。

```c++
#include <bits/stdc++.h>
using namespace std;
int vis[22222];
vector<int>graph[22222];

void dfs(int x) {
	cout << x << " ";
	vis[x] = 1;
	sort(graph[x].begin(), graph[x].end());
	int t;
	for (auto t : graph[x]) {
		if (!vis[t])
			dfs(t);
	}
}

int main() {
	int n, e;
	cin >> n >> e;
	for (int i = 0; i < e; i++) {
		int p, q;
		cin >> p >> q;
		graph[p].push_back(q);
	}
	for (int i = 0; i < n; i++) {
		if (!vis[i])
			dfs(i);
	}
	return 0;
}
```

# 7-4 山

**Drizzle** 前往山地统计大山的数目，现在收到这片区域的地图，地图中用`0（平地）`和`1（山峰）`绘制而成，请你帮忙计算其中的大山数目
山总是被平地**四面**包围着，每一座山只能在水平或垂直方向上连接相邻的山峰而形成。一座山峰四面被平地包围，这个山峰也算一个大山
另外，你可以假设地图的四面都被平地包围着。

### 要求:

输入：第一行输入M,N分别表示地图的行列，接下来M行每行输入N个数字表示地图
输出：输出一个整数表示大山的数目

### 示例:

输入：

```in
4 5
1 1 0 0 0
1 1 0 0 0
0 0 1 0 0
0 0 0 1 1结尾无空行
```

输出：

```out
3



结尾无空行
```

### 范围:

对于 5% 的数据：M，N ≤ 10
对于 100% 的数据：M，N ≤ 2000

### 分析：

这题是连通块，让每块的元素都标记为那块的老大，最后统计下非零元素帮派的人数，若该帮派没被访问过则总数加一。

```c++
#include <iostream>
using namespace std;
const int maxn = 2021;
int a[maxn][ maxn];
int n, m, cnt = 0;
int fa[maxn * maxn], top[maxn * maxn], vis[maxn*maxn];

int find(int x) {
	return fa[x] == x ? x : fa[x] = find(fa[x]);
}

void merge(int x, int y) {
	fa[find(x)] = find(y);
	return;
}

bool check(int x, int y, int x0, int y0) {
	if (a[x][y] && a[x0][y0])
		return 1;
	return 0;
}

int main() {
	cin >> n >> m;
	for (int i = 1; i <= n * m; i++)
		fa[i] = i;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			cin >> a[i][j];
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			if (check(i - 1, j, i, j)) {
				merge((i - 2)*m + j, (i - 1)*m + j);
			}
			if (check(i + 1, j, i, j)) {
				merge(i * m + j, (i - 1)*m + j);
			}
			if (check(i, j - 1, i, j)) {
				merge((i - 1)*m + j - 1, (i - 1)*m + j);
			}

			if (check(i, j + 1, i, j)) {
				merge((i - 1)*m + j + 1, (i - 1)*m + j);
			}
		}
	}
	for (int i = 1; i <= n * m; i++)
		if (a[(i - 1) / m + 1][i - (i - 1) / m * m])
			top[find(i)]++;
	for (int i = 1; i <= n * m; i++)
		if (top[find(i)] && !vis[find(i)]) {
			cnt++;
			vis[find(i)] = 1;
		}
	cout << cnt;
	return 0;
}

```



# 7-5 跳跃

**Drizzle** 被困到一条充满数字的方块路中，假设这条路由一个非负的整数数组`m`组成，Drizzle 最开始的位置在下标 `start` 处，当他位于下标`i`位置时可以向前或者向后跳跃`m[i]`步数，已知元素值为`0`处的位置是出口，且只能通过出口出去，不可能数组越界，请你通过编程计算出Drizzle能否逃出这里。

### 要求:

输入：第一行输入数组`m`的长度`n` 第二行输入数组元素，空格分割开 第三行输入起始下标`start`

### 示例:

输入：

```in
7
4 2 3 0 3 1 2
5结尾无空行
```

输出：

```out
True



结尾无空行
```

### 范围:

- 1 <= m.length <= 5 * 10^4
- 0 <= m[i] < m.length
- 0 <= start < m.length分析：

### 分析：

从给出元素开始搜索，每次走过的元素进行标记，没有越界并且没有访问过的就继续找，直到没有在能找的，如果找到出口元素就退出。

```c++
#include <bits/stdc++.h>
using namespace std;

int n, flag, m1;
int v[55555], a[55555];

void dfs(int x) {
	v[x] = 1;
	if (!a[x]) {
		flag = 1;
		return;
	}
	if (x - a[x] >= 0 && !v[x - a[x]])
		dfs(x - a[x]);
	if (x + a[x] < n && !v[x + a[x]])
		dfs(x + a[x]);
}

int main() {
	cin >> n;
	for (int i = 0; i < n; ++i)
		cin >> a[i];
	cin >> m1;
	dfs(m1);
	if (flag)
		cout<<"True"<<endl;
	else
		cout<<"False"<<endl;
	return 0;
}
```

