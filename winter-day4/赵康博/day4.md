### 7 - 1

---

用容器记录每个点可以到达的点的数量，遍历容器size到达总数量减一的点，把每一个权值相加，记录最小的。

---

### 7 - 2

---

我用的深度优先搜索，每次搜索点可以到达的点，找到终点则返回0，在x可以到达的点中选择返回值最小的，把值加一后返回，递归。

---

### 7 - 3

---

可以用结构体数组记录到达该点的前一个点，最后输出时找前面的点直到到达起点，注意标注起点相同的结。

---

### 7 - 4

---

和第二题相同，可以用深度优先搜索，可以暴力遍历所有的点，把记录最大的并且输出，也别忘记起点中重点相同的结果。

---

### 7 - 5

---

广度优先搜索，对每一个点，能到达的且没记录的地方入栈，用二维数组记录到达每个点的最小值，同理用二维的结构体数组记录记录前面的点，最后往前寻找，找到返回。

---

### 7 - 6

---

主要是看的csdn，正着建图，然后建着反图，在正图上跑从1开始以现金为边权的dij，在反图上用券为边权以n为起点跑一遍dij，然后枚举中间点，遇到不能作为中间点的跳过，能作为中间点的。