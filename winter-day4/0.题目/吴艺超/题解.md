### **7-1 双十一**

**Floyd的板子题，三层for循环，然后再枚举每一个点，求它到其他各点距离的和，寻找和最小的那个点。**

### **7-2 路由器**

**同样可以用Floyd记录任意两点的最短距离。判断是否连通可以将距离跟一个较大的值比较，如果比这个值小就能连通。**

### **7-3 最短路径之Dijkstra**

**输出路径要记录每一个点的前驱，在更新距离的时候同时也更新该点前驱。最后输出的时候可以不断的让该点的值等于自己的前驱来寻找路径。**

### **7-4 最短路径之Floyd**

**用path[ i ] [ j ]表示从i到j要经过的一个点，在修改路径的值的时候一起修改，然后通过递归来输出路径。输出前边的路径（i，path【i】【j】），然后输出该点path【i】【j】，然后输出后边的路径（path【i】【j】，j）即可。**

### **7-5 迷宫变种-最短路径**

**bfs搜索加结构体指针记录路径前驱，相当于将所有的路都搜了一遍，然后每次搜到终点都不断的比较路径的长度，最后不断的回找前驱输出逆序路径。**

### **7-6 森森旅游**

**这个用spfa会变得不幸。跑两遍dijkstra，正向跑跑距离为现金的图，然后反向跑跑距离为旅游金的图，枚举每一个端点 作为分界点，记录总金额并存入multiset的容器中，每次修改时就删除之前的值并存入新的值，输出开始的值即可。**