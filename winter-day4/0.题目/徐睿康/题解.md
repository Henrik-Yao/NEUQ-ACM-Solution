双十一：

​		这道题要求的是一个与其他点距离的和最小的点，我们可以运用最短路的算法来实现这个过程。

​		我使用的是带有堆优化的dij算法，它运用的是贪心的思想，可以计算单源最短路。首先将源点入队，再将与源点相连的所有点入队，运用堆的性质优先出列与源点距离最短的点，并进行与源点类似的操作。因为该算法限制运用贪心的思想，所以需要限制每个点最多只能入队一次，这也限制了它不能进行负边权的处理，如果图中带有负边权则不能使用dij进行处理。

​		举个例子：

​		1->2边权为2,1->3边权为4,3->2边权为-3,这样从1到2的最短路径应该是1,而用dij算法会优先将2入队,这也导致之后找到更优的路径后无法再次对2入队。而另一种最短路算法floyd算法就可以很好的避免这个问题，但它的代价是更高的时间复杂度，dij算法的复杂度为nlogn，而floyd算法的复杂度为n3方。

​		回到这道题，可以跑n次dij，每次算出一个点到其他所有点间的距离和（注意可能有不可到达的点），找到一个距离和最小的点就是所求的答案。



路由器：

​		基本和上题一样，区别在于将无向图换成了有向图并且没有边权，我们将边权人为的赋成1，求出的最小路径即位所求的跳数，注意进行不可到达的判断。



最短路径之Dijkstra：

​		还是很类似，区别在于需要求出最优路径。我们可以在每次松弛操作时，即每次用更小的dis[u]+w更新dis[v]时，用一个数组将v的前驱记为u，初始化时将每个点的前驱计为它本身，完成dij后从终点往前dfs，若找到前驱为他自己则停下来，这样我们就找到了最优的路径。



最短路之floyd：

​		第一次写的时候不会写floyd的储存路径，后来发现写一个n次dij也能过，再后来看了题解也没有很搞懂floyd的路径储存。若没有负边权的情况下还是建议大家使用dij，便于理解，时间复杂度也小。

​		floyd算法中要注意的一点是，枚举中间点的循环一定要放在最外面，不然可能会导致没有找到最短的路径就过早的把最短路确定下来。

![image-20211228103940618](C:\Users\86155\AppData\Roaming\Typora\typora-user-images\image-20211228103940618.png)

​		还有一点，floyd算法路径保存会比dij算法路径保存更难理解一点，二者用的都是前驱，但是用法却不能混为一谈，以下是我抄的题解。



```
	其中我们用 path 数组记录 经过路径 其实 path 的定义如下  path[i][j]  = k 表示 是最短路径 i-……j  和 j 的直接 前驱  为 k 即是： i-->...............-->k ->j
```
举例子：

       如  1-> 5->4   4->3->6  此时 path[1][6] = 0 ； 0表示 1->6 不通  当我们 引入 节点 k = 4 此时有 1->5->4->3->6 显然有 path[1][6] = 3 = path[4][6] = path[k][6]

`如是有 path[i][j] = path[k][j]`
`对于 1->5 相邻边 我们可以在初始化时候 有 path[1][5] = 1;`

`如是对于 最短路径 1->5->4->3->6 有 path[1][6]= 3; path[1][3]= 4; path[1][4]= 5; path[1][5]=1 如此逆推不难得到 最短路径记录值 。`
原文链接：https://blog.csdn.net/start0609/article/details/7779042

​		后来我发现floyd打印路径的方法可能不止一种，这里就不赘述了。



森森旅游：

​		这道题自我感觉还是难一点，最后还是面向csdn编程了，由题意我们可以知道，森森必须在某个城市一次性将他所有的前全部换成旅游金，并在之后的旅程中全程使用旅游金，这相当于森森进行了两种旅游，一种是用本金，一种是用旅游金。这样的话我们可以得到思路：跑两边dij。存边时存两个图，一个正图一个反图，正图存本金的权值，反图存旅游金的权值，然后一遍在正图上跑源点为1的dij，一遍在反图上跑源点为n的最短路，这样我们通过求出每个点到1点的dis1[1]与到n点的dis2[n]之和，再找出所有这些值中最小的值，与之对应的就是所要找的点。

​		但是问题在于，每次更改汇率，所有这些值中的最小值就有可能变化，朴素的做法是每次遍历1到n重新计算对应的值再找到最小的，但问题在于时间复杂度为O（nq），即O（n方），在n小于十万的情况下是会超时的。

​		在网上题解的帮助下，我找到了一个合适的方法，用一个multiset去存储这些值。跑完两次dij后将算出的所有值都加到这个集合里，在set里所有元素是自动排序的，而且multiset不会自动去重，即保证了重复答案的正确性。同时每次更改汇率时，先用lower_bound找出set中原本的值并将其删除，即

​		`st.erase(st.lower_bound(flag));`或者 `st.erase(st.find(flag));`

​		在重新计算一个新的flag并将其插入，即`st.insert(flag);`

​		这样我们每次取出位于第一个位置的set里的数即为答案，可以用指针去找到它 

​		`cout<<*(st.begin())<<endl;`

​		还有要注意的一点是，首先这道题可能有自环，直接continue掉就可以了，其次这道题的数据非常之大，longlong是最基本的，初值还要设的非常大，0x3f3f3f3f3f3f3f3f或者1e18都可以。还要注意的是这个图有可能不连通，即从i到1或n可能为INF，如果在插入值时发现该点不连通就直接continue，在更改汇率是若该点不连通，即这次更改对答案无影响，就直接输出当时的答案，**并continue掉**（这里我没加，运行时错误报了七八次）。



​	