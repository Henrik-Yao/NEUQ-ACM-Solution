# ***7-1：***
Floyd算法，算出每个城市到其他所有城市的总距离，比大小算出最小值，输出极小值对应的城市即可。
***
# ***7-2：***
把每两个路由器之间的权值看为1，应用Floyd算法，算出的最小距离即为最小跳数。
***
# ***7-3：***
Dijkstra算法，首先把起点到所有点的距离存下来找个最短的，遍历一遍看通过刚刚找到的距离最短的点作为中转站会不会更近，如果更近了就更新距离。这样把所有的点找遍之后就存下了起点到其他所有点的最短距离。
***
# ***7-4：***
Floyd算法。本题重点在于输出路径，可以在 **dis(i,k)+dis(k,j)<dis(i,j)** 时记录i，j中间点k，最后通过递归输出路径。
***
# ***7-5：***
用dfs做的，每次dfs时用vector记录这个点，回溯时把这个点删掉，遇到终点时，判断最小值，若最小，则用vector容器中的元素更新要输出的数列。最后逆序输出整个数列。 ~~会超时，但答案过了[狗头]~~
***
# ***7-6：***
用Dijskra最短路算法分别算出:使用现金从城市1出发，到达所有城市的最小花费；使用旅游金从城市i出发，到达城市n的最小花费；通过枚举中转点的方式，得到在第i个城市将现金换成旅游金的情况下所需要的现金总额。最后将所有中转点所要用的花费储存在一个multiset容器cost中。在更新汇率时，将更新前花费从cost中删除，并插入新值，然后输出cost中的最小值即可。
***