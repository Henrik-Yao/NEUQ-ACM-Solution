# 7-1
## Floyed 求多源最短路径，先求出每个点到所有点的路径，最后求一下和，第一个点往最后一个点暴力枚举找最小值即可，输出该点

# 7-2
## 构建有向图，然后迪杰斯特拉算法求路径

# 7-3
## 迪杰斯特拉算法，起点终点相同时则直接输出0

# 7-4
## 弗洛伊德算法，并记录最短路径所经过的点

# 7-5
## 广度优先遍历加优先队列

#  7-6
## 一个正图，一个反图，因为我们要找从1-n之间的点换代金券，那么我们就从正图中找到从1开始的单源最短路，从反图中找到从n开始的单源最短路，都可以用dijkstra算法，然后再枚举这1-n个点（注意如果第i个点到1或n不通，那么不能选择），把枚举出来的值装入multiset容器中，为什么不能装堆呢，因为我们后面需要更改他的代金券的汇率，而STL的优先队列不能更改，而multiset容器也是从小到大，底层用的红黑树效率较高，还可以更改值，最后在输出begin()对应的值就行了

