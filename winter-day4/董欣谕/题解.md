1、双十一

很简单的一道最短路问题，每一个点跑一遍Dijkstra，将这个点到其他点的距离加起来，取最小的距离之和。

或者也可以用Floyd算法。（经实测，此题数据巨水无比，Dijkstra使用大根堆和小根堆竟然都能过，合着你这数据就只有一条通路是吧！）

2、路由器

和第一题类似，同样是每一个点跑一遍Dijkstra，每条边权均为1。最后挨个输出即可。（经实测，此题数据同样巨水无比，与第一题情况相似）

3、最短路径之Dijkstra

Dijkstra模板，注意特判起点和终点相同的情况。

4、最短路径之Floyd

Floyd模板，同样注意特判起点和终点相同的情况。

5、迷宫变种-最短路径

在邻接矩阵中跑一遍Dijkstra即可。注意保存路径及使用DFS方法输出。

6、森森旅游

由于只能换一次货币，所以可以枚举换钱的城市i，算出在每个城市换钱至少需要准备的现金。

计算方法为从起点到城市i需要的现金+从城市i到终点需要的旅游金/在该城市货币的汇率（向上取整）

由于该题数据范围较大（n<=100000）我们肯定不能在每个城市跑一遍Dijkstra，而我们可以发现从起点到每个城市所需的现金和从终点到每个城市所需旅游金在枚举换钱的城市时都是用的上的，所以我们只需要用现金做权值正向建图，从起点跑一遍Dijkstra，再用旅游金做权值反向建图，从终点跑一遍Dijkstra，就能算出在每个城市换钱至少需要准备的现金。

接着是该题的查询过程。由于查询的次数m也很大（m<=100000），肯定要进行在线操作。而每次求n个城市中最少需要准备的现金，应该使用能够随时添加删除一个元素，并能快速查询最小值的数据结构，那当然就是set！可是set是集合，只能存储一个相同元素，所以要使用能存储相同元素的multiset 。每次将更新输入城市需要的最少现金的元素，并输出multiset的第一个元素，即可通过此题。