# **week4**

## **7-1**

正常的判断素数题，就是输入输出格式有点烦人~~（应该是我太菜了）~~

n^2算法即可通过，从2到sqrt(n)判断有无约数即可



## **7-2**

~~哪个大聪明出的题~~也不说f[1]=0。。。。。。

这应该算是简单的dp了吧，每一阶的走法数 **=** 上一阶的走法数 **+** 上上一阶的走法数

f[i]=f[i-1]+f[i-2]



## **7-3**

数据范围较大，可用**埃氏筛法**或者**线筛法**

####  **埃氏筛法：**

​        即判断到某一个数时，若它是素数，则它的倍数都是合数，用一个数组v[]来记录某个数是不是合数即可，时间复杂度是nloglogn

**核心代码：**

```cpp
void su(int a)
{
	for(int i=2;i<=a;i++)
	{
		if(v[i])continue;
		ans++;
		for(int j=i;j<=a/i;j++)//假如a是小于i的数，则在循环到a时，a*i一定已经被筛选过，所以我们只用从i*i开始即可
		{
			v[i*j]=1;
		}
	}
}
```



### **线筛：**

​        在埃氏筛法中。部分的数其实还会重复筛选到，如2 * 6=12，3 * 4=12

​        为了确保每个数只被筛选一次，我们可以选择欧拉筛（即线筛）。

​        我们知道，每个合数都可以分解为几个质数的乘积，此分解是唯一的，所以我们可以用每个数的最小质数因子去筛选它。

​        v[]数组记录某个数的最小质数因子（质数为它本身）

​        prime[]数组记录素数,ans记录素数个数

#### **核心代码：**

```cpp
void primes(int a)
{
	for(int i=2;i<=a;i++)
	{
		if(v[i]==0)
		{
			prime[++ans]=i;
			v[i]=i;
		}
		for(int j=1;j<=ans;j++)
		{
			if(prime[j]>v[i]||prime[j]>a/i)break;//当前枚举的素数不是该数的最小素数因子或者超出范围时结束
			v[i*prime[j]]=prime[j];
		}
    }
}
```



## **7-4**

快速幂，emm，今天讲明白

求a^b

首先，我们可以把b表示为2进制的形式：

b=x0 * 2^0+x1 * 2^1+x2 * x^2+......

则a^b=a^(x0 * 2^0+x1 * 2^1+x2 * x^2+......)=a^(x0 * 2^0) * a^(x1 * 2^1) * ......

=(a^1)^x0 * (a^2)^x1 * (a^4)^x2 * (a^8)^x3 * ......

由此可知，我们只需要判断b的二进制每一位是0或者1即可

#### **核心代码：**

```cpp
ll speedpow(ll a,ll b,ll mo)
{
	ll ans=1;
	ll ca=a;
	for(;b;b>>=1)//b&1判断b的每一位为0还是1
	{
		if(b&1)ans=ans*ca%mo;//ca代表上文的(a^(2^n))
		ca=ca*ca%mo;
	}
	return ans;
}
```

