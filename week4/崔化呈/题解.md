# week4 题解
## 1.素数
	好像暴力直接可以出来
	我用的埃筛。。。
	  #include<bits/stdc++.h>
	  using namespace std;
	  #define MAX 10010
	  int main()
	  {
	    int num[MAX],a,b;    //num意为合数，等于1就是合数
	    memset(num,0,sizeof(num));
	    for(int i=2;i<=MAX;i++)
	    {
	      if(!num[i])
	      {
		for(int j=2*i;j<=MAX;j+=i)   //将素数的倍数标记为合数
		{
		  num[j]=1;
		}
	      }
	    }
	    while(cin>>a>>b)
	    {
	      int nu[10000],ge=0;
	      for(int i=a;i<=b;i++)
	      {
		if(num[i]==0){nu[ge++]=i;}    //注意格式形式
	      }
	      for(int i=0;i<ge-1;i++)
	      {
		cout<<nu[i]<<" "; 
	      }		
	      cout<<nu[ge-1]<<endl;
	    }
	    return 0;
	  }


##  2.炒鸡楼梯
	就是个递归，但注意f[1]=0
	  #include<bits/stdc++.h>
	  using namespace std;
	  int main()
	  {
	    int n,m;
	    long long f[50];
	    cin>>n;
	    f[1]=1;f[2]=1;
	    for(int i=3;i<50;i++)
	    {
	      f[i]=f[i-1]+f[i-2];  //两种选择，走一阶还是俩阶
	    }
	      f[1]=0;   //
	    for(int i=1;i<=n;i++)
	    {
	      cin>>m;
	      cout<<f[m]<<endl;
	    }

	  return 0;
	  }

## 3.求素数个数
	用的欧筛
	用int存放数据即可

	  #include<bits/stdc++.h>
	  #define MAX 10000010
	  using namespace std;
	  int prime[MAX],he[MAX],n,all=0;
	  int main()
	  {
	    cin>>n;
	    for(int i=2;i<=n;i++)
	    {
	      if(!he[i])
	      {
		prime[++all]=i;  //不是合数就是质数
	      }
	      for(int j=1;prime[j]*i<=n&&j<=all;j++)
	      {
		he[prime[j]*i]=1;
		if(i%prime[j]==0)
		{
		  break;   //当乘数是被乘数的倍数时停止筛选，防止重复计算
		}
	      }
	    }
	    cout<<all<<endl;
	    return 0;
	  }


## 4.幂次取余
	取余数的性质：(a*b)%c=(a%c*b%c)%c
	采取快速幂的方式
	  #include<bits/stdc++.h>
	  using namespace std;
	  int main()
	  {
	    long long a,b,c,t,rol;
	      cin>>t;
	    for(int i=1;i<=t;i++)
	    {
		  rol=1;
	      cin>>a>>b>>c;
	      while(b)
	      {
		if(b%2==0)
		{
		  b/=2;           
		  a=a*a%c;       //两两相乘再取余数
		}
		else
		{
		  b-=1;              //b为奇数(1一定处于该情况），故直接用结果rol
		  rol=rol*a%c; 
		  b/=2;
		  a=a*a%c;
		}
	      }
	      cout<<rol<<endl;
	     }
	    return 0;
	  }
