# ACM第四周题目题解

<center>typora     vs2019    韩涵 </center>

## 线性筛（欧拉筛）

线性筛，就是不重复的将需要的部分筛出来，以此简化计算次数。（其余就没啥了）

### 	7.1 素数

​	编写一个程序，求出【a,b】范围内的素数。

###### 	输入格式:

​	输入数据有多组，每组占一行,输入两个数a,b。(整型范围内)

###### 	输出格式:

​	输出【a,b】区间内的素数，空格隔开。（2<=a,b<=10000）

###### 	解题思路：

  	 1. 使用线性筛，将每区间内每个素数和素数的乘积筛去，最后剩下的数即为素数。
  	 2. 使用动态规划，将每一个素数求出后存入数据，在将区间内的素数输出。
  	 3. 使用普通筛，将每区间内每个素数和素数的乘积筛去，最后剩下的数即为素数。

  线性筛和普通筛的区别在于：线性筛一个数据只会筛一次，而普通筛会重复筛去某个元素，所以线性筛更好。

###### 	c++代码（方法2）：


```c++
#include<iostream>
#include<math.h>
using namespace std;
int temp[10001];

int main() {
    int a, b;
    temp[0] = 2;
    temp[1] = 3;
    int t = 1;
    while (cin >> a >> b) {//这里直接把2的倍数删掉了，原因显然
        for (int max = temp[t] + 2; max < b; max+=2) {
            bool flag = false;
            //检查数字是否能被素数除尽
            for (int j = 0; j < t && temp[j] <= sqrt(max); j++) {
                if (max % temp[j] == 0) {
                    flag = true;
                    break;
                }
            }
            if (!flag) temp[++t] = max;
        }
        //输出，这输出真是麻了
        bool flag1 = false;
        for (int i = 0; i <= t; i++) {
            if (temp[i] > b) break;
            if (temp[i] >= a){
                if(flag1) cout<<" ";
                cout << temp[i];
                flag1 = true;
            }
        }
        cout << endl;
    }
}
```

### 7.3 求素数个数

###### 题目详情：

求素数的个数。本题要求编写一个程序，求1~n的素数个数。 要求至少给出两种解法，对于相同的n，给出这两种解法的结果，通过相关数据进行测试，目的是通过对比同一问题不同解法的绝对执行时间体会如何设计“好”的算法。

###### 输入格式:

输入在一行中给出1个整数n(<= 10 000 000)。

###### 输出格式:

对每一组输入，在一行中输出1~n的素数个数。

###### 解题思路：

在7.1所述的三种方法中，使用动态规划和普通筛就根本不可能通过，因为时间限制在200ms内。

使用线性筛，具体的思路看注释。

还有，当数据或者数组较大导致段错误时，应该将数据移出主函数减小内存（移入堆中）。

###### c++代码：

```c++
#include<iostream>
using namespace std;

bool num[10000001] = { false };//区分是否为素数
int prime[10000001] = { 0 };//素数数组

int main() {
    int n, pos = 2, ans = 0;
    cin >> n;
    for (int i = 2; i <= n; i++) {//从2到所选数字
        if (!num[i]) prime[pos++] = i;//将素数写入数组内
        for (int j = 2; j < pos && i * prime[j] <= n; j++) {
            num[i * prime[j]] = true;//乘积一定为合数
            if (i % prime[j] == 0) break;
            //当I除以某个质数余数为0时,说明I为此质数*某个数，继续往下乘将会出现重复筛
        }
    }
    for (int i = 2; i <= n; i++) {
        if (!num[i]) ans++;
    }
    cout << ans;
}
```

## 组合数学

组合数学，又称为离散数学。广义的组合数学就是离散数学，狭义的组合数学是离散数学除图论、代数结构、数理逻辑等的部分。随着计算机科学的日益发展，组合数学的重要性也日渐凸显，因为计算机科学的核心内容是使用算法处理离散数据。

在算法中组合数学是非常重要且很难的一部分，下面两个题目是组合数学中最简单的题目之二。

#### 7.2 炒鸡楼梯

这是大家高中会遇到的题目：楼梯走法，但现在是编写程序完成计算。原理不变，代码实现。

###### 题目详情：

你知道吗？有一种编程题需要自己推导公式，得出公式一下子就能解决问题。

具体步骤就是自己先按顺序推算几个比较小的情况，看看这几个之间有没有规律，找到规律你就能解决问题了。试着解决下面这个问题吧。

```
有一楼梯共M级，刚开始时你在第一级，若每次只能跨上一级或二级，要走上第M级，共有多少种走法？
```

###### 输入格式:

输入数据首先包含一个整数N，表示测试实例的个数，然后是N行数据，每行包含一个整数M（1<=M<=40）,表示楼梯的级数。

###### 输出格式:

对于每个测试实例，请输出不同走法的数量

###### 解题思路：

楼梯的只能走一节或者两节，所以枚举走两节的次数，可以推出对应走一次的次数和总步数。在总次数中固定走两次的次数，求出走一次和两次的排列顺序个数，使用组合数即可。将枚举的答案相加即可。



或者当需要走的节数大于等于3时，假设需要走的节数为n，就可以将步数分解为：先走n-1节，在走一节；或者先走n-2节，在走两节。一直递推就可得出答案。



据此给出两种思路：

1. 将楼梯走法分为走两节楼梯的次数，利用组合函数进行每次分发的求解，最后将答案相加（组合数法）
2. 楼梯的走法从第四级开始就符合Fibonacci数列的递推规律，使用公式计算即可。

显然，<font color='orange'>第二种方法更加快速并且消耗更少的内存</font>，所以详细的第一种解法（Fibonacci数列挺无聊的）会在代码中注释。



在进行代码之前需要理解一件事，在 n ~ n+m-1 的递增数列中一定有数能将1~m整除。所以他们的乘积一定可以除尽m的阶乘 。

###### c++代码：

```c++
#include<iostream>
using namespace std;
int C(int down, int up) {//求组合数函数
    up = up < down - up ? up : down - up;
    int b = 1;
    for (int i = 1; i <= up; i++) {
        b = b * (down - i + 1);
        b = b / i;//前文中理解的事情，不会产生余数
    }
    return b;
}
int main() {
    int n;
    cin >> n;
    while (n--) {
        int a;
        int ans = 0;
        cin >> a;
        if(a == 1){
            cout<<0<<endl;
            continue;
        }
        a = a-1;//题目是从第一节开始
        //最多选2节的次数
        int uppig = a / 2 + 1;//while里会少一种情况，将缺失的数补齐
        int markdown = a % 2 - 2;
        while (uppig > 0) {
            uppig--;
            markdown += 2;
            ans += C(uppig + markdown, uppig);
        }
        cout << ans << endl;
    }
}
```

##### 7.4 幂次取余

此题一定要小心数据的大小，由于给定值非常大，必须要用一定方法进行数据减小。

###### 题目详情：

给定三个正整数A，B和C，求AB mod C的结果，其中mod表示求余数。

###### 输入格式:

首先输入一个正整数T，表示测试数据的组数，然后是T组测试数据。每组测试数据输入三个正整数A，B，C（A，B，C≤1000000）。

###### 输出格式:

对于每组测试，输出计算后的结果，每组测试的输出占一行。

###### 解题思路：

需要快速幂，且本题需要知道一个公式即可：

<center>(a*b)%c=(a%c)*(b%c)%c</center>

###### c++代码：

```c++
#include<iostream>
#include<math.h>
using namespace std;
typedef unsigned long long ull;
int main() {
    int n;
    cin >> n;
    //其余的就挺暴力的
    while (n--) {
        ull a, b, c;
        ull ans = 1;
        cin >> a >> b >> c;
        while (b != 1) {
            a = a % c;
            ans = ans * pow(a, b % 2);
            a = a * a;
            b = b / 2;
            ans = ans % c;
        }
        ans = (ans * a) % c;
        cout << ans << endl;
    }
}
```

