### **求解区间覆盖问题**

---

最多只有m段，如果n<=m，则可以每次一段直接输出n。若n>m，先算出每两个数之间的间距大小，按顺序排列，最多只有m段，要除去m-1个连接从0开始，要使连接最短，把最长的m-1个连接除去即可，先把前m-1个连接的点标记，然后从第一个开始遍历，遇到点则结算以此，最后把剩下的所有到终点的距离结算输出。

---

v使标记的需要断开的点。

```
for(int i = 1; i < n; i++)
    {
        if(!v[i])
        {
            xum+=f[i] - f[i-1];
        }
        else 
        {
            sum+=xum+1;
            xum = 0;
        }
    }
```

### 铺满方格

---

每个n个方格的策略分为，下一个是铺一个的策略f[n-1],下一个是两个f[n-2],下一个是三个f[n-3],的和。

应为有多组数据，可以用数组储存结果。

---

```
long long f[51];
    f[1] = 1;
    f[2] = 2;
    f[3] = 4;
    int n;
    for(int i = 4; i <= 50; i++)
    {
        f[i] = f[i-1] + f[i-2] + f[i-3];
    }
```

