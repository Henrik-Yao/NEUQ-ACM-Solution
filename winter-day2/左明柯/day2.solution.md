#### 7-1.cpp

根据前序序列创建树；

递归求每一层叶子节点的和，用一个数组存每一层的和，数字下标对应第几层； 

遍历数组，找出最大值对应的那个下标。

#### 7-3.cpp

直接暴力

#### 7-5.cpp

用优先队列存储节点的权值，用类似合并果子的方法计算出哈夫曼树的带权路径长度之和。 如果给出的编码中存在一个字母的编码是另一个编码的前缀，说明这不是有效编码。（如果存在这种情况，读取编码时无法确定何时结束） 判断的过程中计算给出编码的带权路径长度之和，若和之前计算出的带权路径长度之和相同，说明给出的哈夫曼编码是正确的。

#### 7-7.cpp

dfs遍历前序中序

#### 7-8.cpp

dfs遍历中序

#### 7-9.cpp

dfs遍历后序中序

