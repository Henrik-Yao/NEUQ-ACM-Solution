/*
7-3 树最近公共祖先
已知树结点为互不相等且不等于0的整数。请编写程序找出非空树中两个结点的最近公共祖先。
例如对于图1(a)所示的树t，结点1和2的最近公共祖先是5；结点2和4的最近公共祖先是8。
               8                1          
    5          3     7       2  3  4          
 1  6  2       4                             
输入格式:
每个测试点包含多组数据，第1行为一个正整数T，表示数组组数。每组数据为2行，
第1行为一组用空格间隔的整数，个数不超过100个，表示带空指针信息的二叉树先根序列。
其中空指针信息用0表示。第2行为空格间隔的两个互不相等的整数A和B，表示给定的两个结点值，
保证A和B肯定在输入的树中。
注：我们已知二叉树与其自然对应的树相比，二叉树中结点的左孩子对应树中结点的左孩子，
二叉树中结点的右孩子对应树中结点的右兄弟。进而我们可以利用“带空指针信息的先根序列构建
二叉树”的方法来构建其对应的树的左孩子-右兄弟存储结构。
如8 5 1 0 6 0 2 0 0 3 4 0 0 7 0 0 0对应图1(a)所示的树，1 2 0 3 0 4 0 0 0对应如图1(b)所示的树。
输出格式:
对每组数据输出一行，为一个整数，表示A和B的最近公共祖先结点的值。
输入样例1:
2
8 5 1 0 6 0 2 0 0 3 4 0 0 7 0 0 0
1 2
8 5 1 0 6 0 2 0 0 3 4 0 0 7 0 0 0
2 4
输出样例1:
5
8
*/
#include <bits/stdc++.h>
using namespace std;
int pre[1005],stk[1005];
stack<int> s;
int main(){
    int T;
    cin>>T;
    while(T--){
    	memset(pre,0,sizeof(pre));
    	memset(stk,0,sizeof(stk));
    	int a,b,t,n=1;
    	cin>>a;
    	stk[a]=n++;
    	s.push(a);
    	while(!s.empty()){
        	cin>>a;
        	if(a){
            	stk[a]=n++;
            	pre[a]=s.top();
            	s.push(a);
        	}
        	else{
            	s.pop();
            	n--;
        	}
    	}
    	cin>>a>>a>>b;
    	if(stk[a]>stk[b]){
    	    t=stk[a]-stk[b];
    	    while(t--) a=pre[a];
    	}
    	else{
    	    t=stk[b]-stk[a];
    	    while(t--) b=pre[b];
    	}
    	while(pre[a] !=pre[b]){
        	a=pre[a],b=pre[b];
    	}
    	cout<<pre[a];
    }
}
