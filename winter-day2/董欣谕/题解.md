1、二叉树叶结点值和最大层
二叉树的存储及求每个叶节点的深度，最后将相同深度的叶节点的值相加，取最大值。
2、重建二叉树
考虑用递归实现。
根据二叉树的遍历规律：中序：左，根，右；后序：左，右，根 ，我们可以分别在中序遍历和后序遍历中寻找根的位置，然后在使用遍历的子串这个位置的左右分别建子树。
具体过程为：
假设当前中序遍历的左右边界为l1,r1，后序遍历的左右边界为l2,r2，因为后序遍历最后一个节点r2就是根，所以我们在中序遍历的l1~r1区间内寻找根。
如果没有找到，说明该序列不合法。否则令pos=该处位置，所以中序遍历的左子树范围是(l1,pos-1)，右子树的范围是（pos+1,r1）。
由于用中序遍历和后序遍历构造的相同部分的子树长度一定是相同的，所有由后序遍历左子树的左边界为l2，可以求得其右边界为l2+(pos-l1)，同理可求得后序遍历右子树的范围是（l1+(r1-pos-1),r2-1）。
如果能构造出这样的序列，最后再求其深度和先序遍历即可。
4、罪犯帮派
标准的并查集模板。
5、 哈夫曼编码
用优先队列存储节点的权值，用类似合并果子的方法计算出哈夫曼树的带权路径长度之和。
如果给出的编码中存在一个字母的编码是另一个编码的前缀，说明这不是有效编码。（如果存在这种情况，读取编码时无法确定何时结束）
判断的过程中计算给出编码的带权路径长度之和，若和之前计算出的带权路径长度之和相同，说明给出的哈夫曼编码是正确的。
6、先序和中序构造二叉树
与第二题类似，但每次递归构造子树的边界范围不一样。
通过第二题的思想，假设先序遍历的左右边界为l1,r1，中序遍历的左右边界为l2,r2，pos为中序遍历中找到先序遍历根的位置。
可以求出先序遍历左子树的范围是（l1+1,l1-l2+pos）右子树是（l1-l2+pos+1,r1），后序遍历的左子树范围是（l2,pos-1），右子树是（pos+1,r2）
7、按层遍历二叉树
与第六题的建树过程相同，按层遍历即树的BFS。
8、后序和中序二叉树
与第二题的建树过程相同。