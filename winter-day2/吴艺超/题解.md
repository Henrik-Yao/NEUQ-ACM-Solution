### **7-1 二叉树叶结点值和最大层**

**根据先序遍历将树建立起来，并记录每个节点的深度。取值操作要注意是叶子节点，即左子树和右子树都为空。要记录一下每一层的个数，因为值可能是负数，所以需要判断该层是否有叶子节点。**

### **7-2 重建二叉树**

**先根据中序和后序建树，根的高度=max（左子树的高度，右子树的高度）+1，可以进行递归实现。删除操作即将所有的都赋值为NULL即可。判断是否合法只需判断子树的值对应相同并且长度相同即可。**

### **7-4 罪犯帮派**

**并查集的板子题，可以用路径压缩找父亲，在找的过程中不断更新。**

### **7-5 哈夫曼编码**

**借助哈夫曼树的两个性质：1.哈夫曼编码可能不唯一，但是哈夫曼编码的长度是唯一的。字符串编码成01串后的长度实际上就是其以频率为权值所构成的任意一颗哈夫曼树的带权路径长度。2.对于任何一个叶子结点，其编号一定不会成为其他任何一个结点编号的前缀—也就是说，题目中给出需要判断的的每个字符的编码，它不会是其他字符编码的前缀。可以用优先队列辅助实现。**

### **7-6 先序和中序构造二叉树**

**反向建树的方式还是渗透了分治法的思想，通过分治把一个序列不断分支成左右子树，知道分治到叶结点。因此我们可以总结出建树的算法思路：在递归过程中，如果当前先序序列的区间为 **[idx_f1,idx_f2]**，中序序列的区间为 **[idx_m1,idx_m2]**，设前序序列的第一个元素在中序序列中的下标为 k，那么左子树的结点个数为 **num = (k − idx_m1)** 。**这样左子树的先序序列区间就是 **[idx_f1 + 1, idx_f1 + num]**，左子树的中序序列区间是 **[idx_m1,k − 1]**；右子树的先序序列区间是 **[idx_f1 + num + 1,idx_f1]**，右子树的中序序列区间是 **[k + 1,idx_m2]**，由于我按照先序序列的顺序安排结点，因此当先序序列的 **idx_f1 > idx_f2** 时，就是递归的结束条件。**

### **7-7 按层遍历二叉树**

**首先通过先序和中序遍历将树建立，然后用队列实现按层遍历，如果队首存在左右子树，就将他们入队，然后队首出队即可。**

### **7-8 中序遍历二叉树**

**根据完全二叉树编号的性质可以用来建树，如果左/右儿子编号存在，就建树，否则就是NULL。注意输出的格式，最后是没有多余的空格的。**

### **7-9 后序和中序构造二叉树**

**后序和中序遍历的左子树都是在开头，然后右子树就差一个根的位置，根据这个性质可以分治建树。**