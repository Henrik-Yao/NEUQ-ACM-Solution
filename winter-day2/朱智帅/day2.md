# 7-1

构建一颗二叉树，构建过程中，通过用high为下标表示每一层叶子节点的和，然后取最大值。

# 7-2

根据中序和后序的位置，判断根节点，左子树所在区间，右子树所在区间，两个序列中，相应元素完全相同，是则递归调用，否则判错。

# 7-3

运用堆栈简化树的构建，每次只记录节点的值，高度，父节点序号，根据先序遍历的特点，输入时，若不为零则为当前栈顶的孩子节点，压入后深度+1，否则下一次输入为栈顶的兄弟节点。之后根据所给目标序号不断寻找父节点（PS：在对堆栈进行判空时要使用empty()进行用size()会超时）。

# 7-4

Floyd算法解决，不知道为什么算在树的习题里。

# 7-5

运用数组模拟哈夫曼树的构建，运用三叉树，数组最终长度为2*n-1，运用找父节点的方法得出深度，之后得出总查找长度，若不同则判错，否则，继续判断短的编码是否为长编码前缀，不是则正确否则错误。

# 7-6

根据中序和先序的位置，判断根节点，左子树所在区间，右子树所在区间，两个序列中，相应元素完全相同，是则递归调用，否则判错。

# 7-7

根据中序和先序的位置，判断根节点，左子树所在区间，右子树所在区间，两个序列中，相应元素完全相同，是则递归调用，否则判错。之后运用队列进行层序遍历。

# 7-8

构造二叉树，用队列解决输出中的空格问题。

# 7-9

根据中序和后序的位置，判断根节点，左子树所在区间，右子树所在区间，两个序列中，相应元素完全相同，是则递归调用，否则判错。之后运用队列进行层序遍历。