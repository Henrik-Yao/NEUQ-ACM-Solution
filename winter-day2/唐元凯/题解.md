# Day 2 题解
## 7-1 二叉树叶结点值和最大层 
首先得分析题意：注意`数据域为不等于0的整数`  ，这说明只有最外边的叶子可以是0，因而也就可以仅凭先序遍历确定一颗二叉树  
首先读入二叉树，随后根据先序遍历的规则进行建树+求解，由于是要找数据最大的一层，因此在递归建树时，直接传入层数，并将递归返回值`sum[floor]`求和保存。最后建树完成时，求和同步完成。  
此时，还要注意一点，这道题题目中没有讲清楚，数据值之和最大指的是其绝对值最大  
* * * 
## 7-2 重建二叉树 
首先判断是否给出的后序遍历和中序遍历是否合法，判断方法为：  
>由定义可知，后序遍历的最后一个元素即为根  
>在中序遍历中找到该根，左边即为左子树，右边即为右子树
>以此为例：  
>`C|EFDB|HGA`  
>`C|BEDF|AGH`  
>可见一对合法序列的左右子树中的元素应当完全匹配  

随后建树+dfs求解即可
* * * 
## 7-3 树最近公共祖先 
这道题一开始我开了10000的数组，运行超时，反复纠结，直到我把开的数组减到1000。。。  

思路是通过一个二维vector：`vector<vector<int>>` 来动态保存每个节点下的数据，即建树，随后递归遍历该树，每个节点维护一个独立的sig值，该值初始为0，每找到一个相符值+1,每个节点向上一个节点返回其拥有的sig值，第一个达到2的节点即为所求节点
* * * 
## 7-4 罪犯帮派 
这道题是并查集的基本应用。并查集是个神奇的东西，根节点会自己变成一个！需要注意的是没有信息的罪犯默认是属于不同的帮派。  

并查集的核心代码为：`int findroot(int x) { return p[x] == x ? x : (p[x] = findroot(p[x])); }`  
* * *
## 7-6 先序和中序构造二叉树  
由定义可知，先序遍历的第一个元素即为根，随后建树，遍历即可 
* * *
## 7-7 按层遍历二叉树
由定义知，先序遍历的第一个元素即为根  
随后建树，用队列进行bfs  
* * *
## 7-8 
* * *
## 7-9 后序和中序构造二叉树 
由定义可知，后序遍历的最后一个元素即为根，随后建树，遍历即可 