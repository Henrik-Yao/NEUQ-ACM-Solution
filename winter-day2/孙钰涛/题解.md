# ***7-1：***
用数组来表示二叉树。按照先根顺序创建二叉树，用结构体记录每个结点的深度和值，用一个数组来统计一层的叶子结点的和(注意是叶子结点)。最后输出数值中的最大元素对应得层数即可。
***
# ***7-2：***
用递归的方法来寻找一个个结点，一旦找不到这个结点就输出“INVALID”。在找的同时也用链式储存结构来创建二叉树。通过递归找出树的最大深度，dfs输出先根顺序。
***
# ***7-3：***
按题意类比，创建二叉树，可以用栈的方法，遇到0就pop，简单又轻松。这题要注意不要超时，将cin改为scanf可以快一点，也可以直接LCA。
***
# ***7-4：***
用数组关联罪犯的编号和他所在的帮派，两个都没帮派的人组成帮派，一个人有帮派则另一个人加入，两个人都有帮派则帮派合并。当一个人没被提到时，他自成一个帮派。 ~~我被这折磨了好久~~
***
# ***7-5：***
根据输入，将字符出现的频率，加入优先队列(从小到大)中，方便后面计算。并使用map对字符进行标记，标记每个字符对应的频率。每次从优先队列中取出两个最小的数，进行加权，直到队列中只剩一个元素时，循环结束，计算最优带权长度成功。最后就进行判断，每组数据符不符合条件。条件1:判断每组的带权路径长度是否和最优路径长度相等；条件2:判读每个字符的编码方式是否合法，即每个字符之间的编码是否有歧义(前缀包含)。
***
# ***7-6：***
递归方法，从先序序列和中序序列中找到结点，依次创建二叉树。然后按根、左、右的顺序遍历二叉树，输出后序序列。递归的表达式注意一下。
***
# ***7-7：***
同7-6，只不过输出时按层输出，用bfs的思想就好了。
***
# ***7-8：***
现有层次遍历得二叉树得数组，然后就可以得到中序遍历得数列了，注意每组数据数组得初始化。
***
# ***7-9：***
同7-6
***