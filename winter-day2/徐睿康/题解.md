罪犯帮派：

​		这是一个非常经典的算法——并查集算法的一道模板，并查集算法是将每个元素赋予一个父亲，用fa数组来存储，开始时每个人的父亲都是他自己，若某两个人属于一个帮派，则可以将其中一个人的父亲改成另一个人，同理，我们可以通过不断地操作得到一个家族谱图，通过这个图就可以轻松的判断两个人的祖先是不是同一个人，也就可以判断两个人是不是属于一个帮派

​		需要注意的时，findd函数里有一步行之有效的优化，即路径压缩，他将寻找祖先的路径上的所有人的直接父亲都改成祖先，这样可以省去许多查找时浪费的时间。



二叉树叶节点值和最大层：

​		这道题要注意求的是叶节点处的值，注意建图是可以在dfs里边跑边输入，不用先将其看作字符串输入。

​		将相同层数的叶子节点的值加到对应位置的数组中去（注意权值可能为负数，要注意对数组的预处理），然后循环找出最大值。



先序和中序构造二叉树：

​		给定先序与中序，二叉树是唯一确定的。可以递归的处理这些数据，可以将dfs定义为int类型，每次返回对应子树的根节点。dfs中传入四个参数，分别是两个序列的左端坐标与右端坐标。先序序列的左端坐标即对应的是当前对应子树的根，通过这个根将两个线段分成四份，再递归的去处理。注意这里有**严格的公式**去推出四个线段的起止位置，千万别推错了，多手写几组数据试试看。

​		建好树后即可愉快的dfs中序遍历二叉树了。



中序遍历二叉树：

​		注意到这里的二叉树是以完全二叉树的形式给出的，我们知道完全二叉树中节点i的两个儿子分别为 i* 2 与i* 2+1，从1开始用n去限制这两个值即可完成建树。

​		要注意到该书中可能有虚节点的存在，建树是可以将其看做完全二叉树，遍历时可不行，而且我第一次写的时候想要通过完全二叉树中最大节点数与n的关系来直接判断树的深度，这显然是不行的，该dfs就老老实实dfs。



后序和中序构造二叉树：

​		这道题与先序中序二叉树同理，只不过将先序改成了后序，即每个子树的根出现在后序序列的最右端，还是需要注意四个线段起止位置的确定，可以多手写几组数据来进行公式的判断与验证。



重建二叉树：

​		仍然同理，只不过将数字改成了字符，还添加了合法性的判断。合法性判断可以通过每次处理两个序列时判断两个序列中的元素是否完全相同（次序肯定可以不同）来判断该序列是否合法，若不合法直接return掉。深度处理同上，处理字符时可能需要更多的码量，这就需要我们有更强的码力与更好的心态。（我什么时候能有？？？）



按层遍历二叉树：

​		用队列储存未遍历的节点，并将队首的节点的儿子节点入队，不断输出队首节点并pop即可实现按层遍历二叉树。还有一点要注意的是，这道题的数据范围可能有点问题，并不是只有十个点，可能需要再开大数组，不然数组越界会报段错误。
