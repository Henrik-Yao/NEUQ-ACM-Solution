# 7-1

## 题目

> 已知一棵非空二叉树结点的数据域为不等于0的整数，请编写程序找出该二叉树中叶结点数据值之和最大的层。

## 实现方法

在原来二叉树的基础上加入level记录每个结点所在层数，建树之后先序遍历树找到叶节点并用sum数组计数该层的所有叶节点数字之和，最后找到最大的输出即可



# 7-2

## 题目

> 给定非空二叉树的中根序列和后根序列，请编写程序创建该二叉树，计算其高度和先根序列，最后删除该二叉树；如给定的中根和后根序列不合法，则亦能识别。

## 实现方法

先判断中序序列和后序序列是否有效，后序序列的最后一个字母即为树的根，由此将中序序列分为左右两部分，依次建树，最后用先序遍历将其输出。求高度时用递归的求法，返回左子树和右子树最大高度+1。



# 7-4

## 题目

> abu市的警察局决定结束混乱，因此要采取行动根除城市中的几大帮派。目前的问题是，给出两个罪犯，他们是属于同一帮派么？城市里一共有多少个帮派？假设在Tabu市现有n名罪犯，编号为1到n，给出m条消息表示属于同一帮派的两个罪犯编号。请基于这些不完全的信息帮助警方计算出他们想要的信息。

## 实现方法

并查集的简单应用



# 7-5

## 题目

> 给定一段文字，如果我们统计出字母出现的频率，是可以根据哈夫曼算法给出一套编码，使得用此编码压缩原文可以得到最短的编码总长。然而哈夫曼编码并不是唯一的。例如对字符串"aaaxuaxz"，容易得到字母 'a'、'x'、'u'、'z' 的出现频率对应为 4、2、1、1。我们可以设计编码 {'a'=0, 'x'=10, 'u'=110, 'z'=111}，也可以用另一套 {'a'=1, 'x'=01, 'u'=001, 'z'=000}，还可以用 {'a'=0, 'x'=11, 'u'=100, 'z'=101}，三套编码都可以把原文压缩到 14 个字节。但是 {'a'=0, 'x'=01, 'u'=011, 'z'=001} 就不是哈夫曼编码，因为用这套编码压缩得到 00001011001001 后，解码的结果不唯一，"aaaxuaxz" 和 "aazuaxax" 都可以对应解码的结果。本题就请你判断任一套编码是否哈夫曼编码。

## 解题思路

利用哈夫曼编码的两个性质：根节点的值为所有权值路径乘积之和；所有编码都不是其他编码的前缀求解该题



# 7-6

## 题目

> 本题目要求用先序序列和中序序列构造一棵二叉树（树中结点个数不超过10个），并输出其后序序列。

## 实现方法

前序序列的第一个字母即为树的根，由此将中序序列分为左右两部分，依次建树，最后用后序遍历将其输出。



# 7-7

## 题目

> 用先序和中序序列构造一棵二叉树（树中结点个数不超过10个），通过用队记录结点访问次序的方法实现对二叉树进行按层遍历，即按层数由小到大、同层由左到右输出按层遍历序列。

## 解题思路

前序序列的第一个字母即为树的根，由此将中序序列分为左右两部分，依次建树，最后用后序遍历将其输出。





