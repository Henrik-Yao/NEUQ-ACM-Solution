### 7 - 1

---

直接输入，把输入的位置数组标为1，遍历一遍找相邻两个都是1的。

---

### 7 - 3

---

直接都输入到一个数组中，用sort排序，输出中间的就行，不需要去重。

---

### 7 - 4

---

正常的二分查找题。

---

### 7 - 5

---

用map存储数据，可以建结构体存储姓名还有性别，在输入的时候把性别标记好，把姓后面的后缀去掉，方便后面判断，用集合存储两人的祖先，判断是否有相同的情况，另外，另定义一个集合存储五代以外的祖先，因为题目可能会出第三代和第九代的情况，这种情况也是no。

```
for(int j = 0; j < 4 && !c.empty(); j++)
            {
                if(num.find(c)!=num.end()|| num2.find(c)!=num2.end())
                {
                    t=1;
                    break;
                }
                c = f[c].s;
            }
            while (!c.empty()&&!t)
            {
                if(num.find(c)!=num.end())
                {
                    t = 1;
                    break;
                }
                c = f[c].s;
            }
```



---

### 7 - 6

---

正常二分题，查找的时候记录一下次数。

---

### 7 - 7

---

要找到最小的距离，用二分在最大值和最小值之间查找，没找一次判断是否可行，可行则向右找，不行则向左边找，判断的标准为，存在间距差够的牛棚数量大于等于牛的数量。

```
bool judge(int x)
{
    int num = 1;
    int left = 0,right;
    for(int i = 1; i < n; i++)
    {
        right = i;
        if(f[right] - f[left] >= x){
            left = right;
            num++;
        }
    }
    if(num >= m)return true;
    else return false;
}
```



---