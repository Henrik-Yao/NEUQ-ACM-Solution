## 7-1

排个序，双指针，复杂度是$O(nlogn)$的

不过这题直接平方暴力就过了

## 7-2

好像卡了一堆人...

先建颗Trie树，然后每次查询先往下走，走完之后dfs往下把所有节点都加到一个vector里，然后排序输出前k个即可

不过很容易看出来，上面的做法复杂度是不太对的，考虑最坏的情况，我们插入$a(a...z...0...9)(a...z...0...9)...$，然后每次查询一个$a$，这样就能卡到$O(mnlogn)$，不过数据似乎很水，这样就能水过。

关于复杂度正确的做法，我没有什么简便的想法，提供一个比较麻烦的：

还是先建Trie树，然后将询问离线，按照Trie树自底向上的顺序处理。

处理的过程考虑用若干个可并堆自底向上的维护，每次取出前$k$个最大值，然后父节点合并子节点即可。

可并堆的实现可以使用左偏树或者pbds（如果支持的话）

如果使用左偏树实现，那么复杂度是$O(20m + nlogn)$的

~~想问问选题人真的做过它选的题吗？，如果有很简单的正确做法当我没说~~

## 7-3

中位数，这里推荐使用STL的nth_element，复杂度是$O(n)$的（原理是快速排序的Partition）

## 7-4

二分查找，这个输出次数很魔性，大概是这样：

```c++
while(l <= r)
{
    mid = (l + r) >> 1; ++cnt;
    if(a[mid] == x) break;
    if(a[mid] < x) l = mid + 1;
    else r = mid - 1;
}
```

## 7-5

和之前双周赛的某题类似，但是要注意这个五代祖先的定义略有不同

## 7-6

二分查找，排个序直接lower_bound就行

## 7-7

这类“最大化最小值“、”最小化最大值“的题一般都会扯到二分答案

首先二分答案，Check的时候考虑贪心：从左往右，如果当前牛舍与上一个选择的牛舍距离超过了二分的mid，那就在当前牛舍放一头牛，重复这个过程直到数量超过$m$即可。
