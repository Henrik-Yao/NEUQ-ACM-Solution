## 7-1

用map存储词典，然后对于每个单词直接查找即可。

## 7-2

可能有多个括号嵌套，所以考虑使用递归

每次遇到 '[' 的时候，我们就递归处理这个括号对里面的区间，然后将得到的字符串复制相应的倍数即可。

要知道每个'['对应的区间是多少，就是找它所匹配的']'

这是一个经典问题（括号匹配），使用栈处理即可。

## 7-3

字符集是很小的，所以直接使用一个桶记录每个字符是否属于第二个字符串即可。

注意是多组输入

## 7-4

题目意思即为最长上升子序列，$n≤1000$，$O(n^2)$可过，直接进行$dp$即可

设$f_i$表示以$i$结尾的最长上升子序列长度，则$f_i = max_{j<i\ \&\ a_i>a_j} \{f_j + 1 \}$

值得一提的是LIS问题有$O(nlogn)$的做法，本文不在此赘述

## 7-5

经典的$01$背包问题，设$f_{i,j}$表示前$i$个物品，最多使用$j$的容量时的最大价值

则
$$
f_{i,j} = max\{f_{i-1,j-w_i} + v_i,\ f_{i-1,j}\}
$$
注意到第一维只使用了$i-1$的状态，可以使用滚动优化降低空间复杂度

调整枚举$j$时的顺序（从大到小），只需一维数组即可完成转移

时间复杂度$O(nc)$，空间复杂度$O(c)$