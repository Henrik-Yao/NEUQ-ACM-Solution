week7题解

1字典

知识点：map容器，其实就是一个特殊的数组，以往的数组使用的是下表标记，但是map中允许使用更多的变量类型，包括自己定义的，并且map是一个一一对应的映射。包含头文件map；

迭代器：迭代器（Iterator）的介绍
背景：指针可以用来遍历存储空间连续的数据结构，但是对于存储空间费连续的，就需要寻找一个行为类似指针的类，来对非数组的数据结构进行遍历。
定义：迭代器是一种检查容器内元素并遍历元素的数据类型。
迭代器提供对一个容器中的对象的访问方法，并且定义了容器中对象的范围。
迭代器（Iterator）是指针（pointer）的泛化，它允许程序员用相同的方式处理不同的数据结构（容器）。
（1）迭代器类似于C语言里面的指针类型，它提供了对对象的间接访问。
（2）指针是C语言中的知识点，迭代器是C++中的知识点。指针较灵活，迭代器功能较丰富。
（3）迭代器提供一个对容器对象或者string对象的访问方法，并定义了容器范围。

迭代器和指针的区别：
容器和string有迭代器类型同时拥有返回迭代器的成员。如：容器有成员begin和end,其中begin成员复制返回指向第一个元素的迭代器，而end成员返回指向容器尾元素的下一个位置的迭代器，也就是说end指示的是一个不存在的元素，所以end返回的是尾后迭代器。

map<int ,string>zd

前一个是关键词，后一个是对应的值（一一对应的关系），最后面的是定义的map的名称

在这个map中，如果定义n是整型变量，s1是字符串，那么zd[n]=s1是合法的，而zd[s1]=n是不合法的。



题目：

你刚从滑铁卢搬到了一个大城市，这里的人们讲一种难以理解的外语方言。幸运的是，你有一本字典来帮助你理解它们。

### 输入格式:

输入第一行是正整数N和M,后面是N行字典条目（最多10000条），然后是M行要翻译的外语单词（最多10000个）。每一个字典条目都包含一个英语单词，后面跟着一个空格和一个外语单词。 输入中的每个单词都由最多10个小写字母组成。

### 输出格式:

输出翻译后的英文单词，每行一个单词。非词典中的外来词汇输出“eh”。

思路：将字典的条目一一存进map中，并进行遍历。1

#include<iostream>
#include<map>
#include<cstring>
#include<iterator>
using namespace std;
int main()
{
	map<string, string>zd;//定义一个zd的map容器
	map<string, string>::iterator iter;//声明一个迭代器iter（iter是名字）
	string s1, s2, s3;
	int n, m;
	cin >> n >> m;
	for (int i = 0; i < n; i++)
	{
		cin >> s1 >> s2;
		zd[s2] = s1;//将外国词语的条例作为关键词（因为检索的对象就是外来词语）
	}
	for (int i = 0; i < m; i++)
	{
		cin >> s3;
		iter = zd.find(s3);//利用迭代器和find函数进行遍历查找
		if (iter != zd.end())//zd.end()表示没有找到，迭代器返回了默认值
		{
			cout << zd[s3] << endl;
		}
		else
		{
			cout << "eh" << endl;
		}
	}

	return 0;

}

2神秘密码

传说二战时X国收到了上帝的一串密码，只有解开密码，才能阻止战争的继续进行，世界才会恢复和平。解开密码的第一道工序就是解压缩密码，上帝对于连续的若干个相同的子串"X"会压缩为"[DX]"的形式(D是一个整数且1<=D<=99),比如说字符串"CBCBCBCB"就压缩为"[4CB]"或者"[2[2CB]]",类似于后面这种压缩之后再压缩的称为二重压缩。如果是"[2[2[2CB]]]"则是三重的。现在我们给你上帝发送的密码，请你对其进行解压缩。

### 输入格式:

一个字符串

### 输出格式:

一个字符串

思路：

我的初始思路：

既然是两个字符串的输入输出，那么就用string，遇到'['那么下一个元素必定是一个数值，用一个int变量记录倍数，并从这个数的下一个开始，就是我们要解压的元素了，直到遇见']'就停止，输出倍数个这样的串即可，但是显然考虑不周，如果解压穿插着多组这样的压缩呢，于是我想回溯，可是这样这道题的写法就会很麻烦

解决思路：抛弃字符串，使用单个字符去判定，原理同上，但是使用字符时：while(cin>>ch)非常关键，它允许我们进行多组解压。如果碰到了'['那么就要输入压缩的倍数了，这个时候之前定义的连个字符串变量，一个时暂时值，即st。其实下面这个递归很好理解，就是加入这个密码段没有压缩，那么我输入的只是sf，跟st没有关系，所以+ch的一定是sf，返回的也一定是sf，之所以由st实在解压的时候用来记录子串。而碰到]就说明这一部分的解压结束了，所以输出sf；

#include<iostream>
#include<cstring>
using namespace std;
string find();
int main()
{
	cout << find();
	return 0;
}
string find()
{
	string sf = "", st;
	int n;
	char ch;
	while (cin >> ch)
	{

		if (ch == '[')
		{
			cin >> n;
			st = find();//利用st来将需要重复的字串记录
			while (n--)
			{
				sf += st;
			}
		}
		else
		{
			if (ch == ']')
			{
				return sf;
			}
			else
			{
				sf += ch;
			}
		}
	}
}

3删除公共字符

输入两个字符串，从第一个字符串中删除第二个字符串中的所有字符。例如，输入“They are students.”和“aeiou”，则删除之后的第一个字符串变成“Thy r stdnts”。

### 输入格式:

输入包含多组测试，每个测试输入包含两个字符串。

### 输出格式:

输出删除后的字符串。

思路：其实可以用最简单的遍历去做，加一个bool的判断数组就可以了。或者使用map但是使用erase的做法好像在这道题也并没有那么简单，最简单的是使用asc值取进行bool判断并输出，这个方法很巧妙，并且时间复杂度也很好（n),如下：

因为所有的字符都在asc值中有自己对应的值，所以只需要将这些值对应的下标的bool数组该值，判断是否输出即可。

#include<iostream>
#include<cstring>
#include<string>
#include<map>
using namespace std;

int main()
{
	int a[256];
	string s1, s2;
	while (getline(cin, s1)&&getline(cin, s2))
	{


		for (int i = 0; i < 256; i++)
		{
			a[i] = 0;
		}


​		
​		
		int n = s1.length();
		int m = s2.length();
		for (int i = 0; i < m; i++)
		{
			int temp = s2[i];
			a[temp] = 1;
		}
		for (int i = 0; i < n; i++)
		{
			int temp2 = s1[i];
			if (a[temp2] == 0)
			{
				cout << s1[i];
			}
		}
		cout << endl;
	}
	return 0;
}

4 最长有序子序列

对于给定一个数字序列 (*a*1，*a*2，…，*a**n*) ，如果满足*a*1<*a*2<…<*a**n*，则称该序列是有序的。若在序列(*a*1，*a*2，…，*a**n*) 中删除若干元素得到的子序列是有序的，则称该子序列为一个有序子序列。有序子序列中长度最大的即为最长有序子序列。

例如，(1，3，5)、(3，5，8)、(1，3，5，9)等都是序列 (1，7，3，5，9，4，8) 的有序子序列；而(1，3，5，9)、(1，3，5，8)、(1，3，4，8)都是序列 (1，7，3，5，9，4，8)的一个最长有序子序列，长度为4。

请编写程序，求出给定数字序列中的最长有序子序列的长度。

### 输入格式:

首先输入一个正整数T，表示测试数据的组数，然后是T组测试数据。每组测试数据第一行输入一个整数 n（1≤n≤1000），第二行输入n个整数，数据范围都在[0，10000]，数据之间以一个空格分隔。

### 输出格式:

对于每组测试，输出n个整数所构成序列的最长有序子序列的长度。每两组测试的输出之间留一个空行。

**思路：**本来觉得挺难的，后来看到dp瞬间就明白了，但是使用dp要先明白dp的递推关系。

本题的dp递推是：dp[m]=max(dp[i]);即第m个元素的dp值是所有在他前面且比他小的dp值中最大的值再加一，其实很好理解哈。且注意dp[0]=1;
#include<iostream>
#include<algorithm>
using namespace std;
int max(int a, int b);
int a[1001];
int dp[1001];
int main()
{
	int t;
	cin >> t;
	for (int i = 1; i <= t; i++)
	{
		int n;
		cin >> n;
		for (int j = 0; j < n; j++)
		{
			cin >> a[j];
		}
		for (int u = 0; u < n; u++)
		{
			if (u == 0)
			{
				dp[u] = 1;

			}
			else
			{
				dp[u] = 1;
				int flag = 0;
				for (int y = 0; y < u; y++)
				{
	
					if (a[u] > a[y])
					{
						flag++;
						dp[u] = max(dp[y], dp[u]);
	
					}
	
				}
				if (flag)
				{
					dp[u]++;
				}
			}
		}
		sort(dp, dp + n, less<int>());
		cout << dp[n - 1] << endl;
		if(i!=t)
	    {cout << endl;}
	}



	return 0;
}
int max(int a, int b)
{
	return a > b ? a : b;
}

**5背包问题**

给定n种物品（每种仅一个）和一个容量为c的背包，要求选择物品装入背包，使得装入背包中物品的总价值最大。

### 输入格式:

给定n种物品（每种仅一个）和一个容量为c的背包，要求选择物品装入背包，使得装入背包中物品的总价值最大。

测试数据有多组，处理到文件尾。每组测试数据输入3行，第1行为两个整数n（1≤n≤400）和c (1≤c≤1500)，分别表示物品数量与背包容量，第二行为n个物品的重量*w**i*（1≤i≤n），第三行为这n个物品的价值*v**i*（1≤i≤n）。物品重量、价值都为整数。

### 输出格式:

对于每组测试，在一行上输出一个整数，表示装入背包的最大总价值（结果保证在int范围内）。

思路：经典dp，还是老样子，搞清楚递推的原理，递归出dp表即可，注意可以用sort输出最大值。

这道题用值和重量构建dp的二位数组表。如果剩余的重量j不足以能够盛放这个物品那么相当于没有装入这个物品如果足以盛放这个物品，那么去比较放入这个物品和不放入谁更大，注意放入时要加上第i个物品的值，且此时要减去这个物品i的质量。

#include<iostream>
using namespace std;
const int w = 1501;
int wei[w];
int val[w];
int dp[w][w] = { {0} };//初始定义，而当值均为0时也确实dp值为0

void qiudp(int n, int c);
int max(int a, int b);
int main()
{
	int n, c;

	while (cin >> n >> c)
	{
		for (int i = 1; i <= n; i++)
		{
			cin >> wei[i];
		}
		wei[0] = 0;
		val[0] = 0;
		for (int i = 1; i <= n; i++)
		{
			cin >> val[i];
		}
		qiudp(n, c);
		int sum = 0;
		for (int i = 1; i <= n; i++)
		{
			for (int j = 1; j <= c; j++)
			{
				sum = max(sum, dp[i][j]);
			}
		}
		cout << sum << endl;
	}
	return 0;
}
void qiudp(int n, int c)
{
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= c; j++)
		{
			if (j < wei[i])                          //如果剩余的重量j不足以能够盛放这个物品
			{
				dp【i]【j] = dp【i - 1]【j];//那么相当于没有装入这个物品
			}
			else
			{
				dp【i]【j] = max(dp【i - 1]【j], dp【i - 1]【j - wei[i]] + val[i]);//如果足以城防这个物品，那么去比较放入这个物品和不放入谁更大，注意放入时要加上第i个物品的值，且此时要减去这个物品i的质量。
			}
		}
	}
}
int max(int a, int b)
{
	return a > b ? a : b;
}
