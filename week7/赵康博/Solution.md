### 7 - 1

---

用map储存外语和对应的意思，然后直接查找就行了。

---

### 7 - 2

---

用string 来存储密码，每个读入字符若是‘['则代表下一个是整形n（由于可能是两位数所以不能直接用char读入），读入整数后，整数后面的内容可以看成一个新的字符串，递归直到遇到']'。把递归返回的string 加n次到储存的string内，最后输出。

---

### 7 - 3

---

用getline 输入，遍历第二个字符串的字符，在第一个字符串内用find函数，直到超出范围，对找到的字符标记，最后只输出没有标记的字符。

---

### 7 - 4

---

建立储存数组f,遍历数组，在s[i]上判断每一个数，如果s[j]比s[i]小则储存的数组f[i] = f[j] + 1和s[i]较大的，相当于在原有的最大子序列和在j处的最大子序列加一后的结果取较大的更新f。如果s[j]>s[i]则不能作为s[j]后续无法更新，在每个s[i]循环后判断最大值，最后输出。

---

```
for(int i = 0; i < m; i++)s[i] = 1;
        for(int i =0; i < m; i++){
            for(int j = 0; j < i; j++){
                if(f[i]>f[j])s[i] = max(s[i],s[j]+1);
            }
            max1 = max(max1,s[i]);
        }
```

### 7 - 5

---

建立储存最大价值数组f，从一个样品开始判断，每一样品从最大容积开始到0，如果容积大于样品的消耗则可以考虑，如果拿这个物品，价值会变成拿物品剩余的容积所对应的最大价值加上这个物品的价值，如果不拿则和没有次物品的价值不变，判断最大的更新f。由于每一层的最大的价值并不需要都储存，在n层的时候，n-2层还有以上的都不在需要，故可以用一维数组，更新之前代表的是上一层的价值，更新后代表最新层的价值。最后输出最后一层的最大体力的价值。

---

```
for(int i = 0; i < n; i++){
        for(int j = v; j >= 0; j--){
            if(j-m[i]>=0)
            f[j] = max(f[j],f[j-m[i]]+k[i]);
        }
    }
```