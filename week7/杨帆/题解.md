# 5-1

懂得都懂，我就不啰嗦了

***

# 5-2

一道灰常精妙的递归题（每一道递归都很精妙就对了）

这道题的核心思想就是**编写一个递归函数，输入字符串，遇到“【”就再次调用，直到遇到“】”才开始返回已经输入的字串**

> 例如：AC[3FUN]，调用，输入AC，遇到‘【’，用n存储‘3’，调用函数，在用一个字符串str1来存储FUN，遇	     到‘】’ ，返回str1；

```
while(cin >> ch){
	if(ch == '['){
		cin >> n;
		str2 = function();
		while(n--)	str1 += str2;
	}
	else if(ch == ']')
		return str1;
	else
		str1 += ch;
}
//	str1是最终返回的字符串，str2是临时的
```

***

# 5-3

灰常恶心的一道题，重点就是两个输入都要用getline，用cin输入第二个串就会出问题，其他就没什么了

***

# 5-4

~~一道挂着dp的名号但是用dp不给过的题~~，可能是我的dp的方法不对，时间复杂度是（n^2)，最后是用贪心加二分过的，时间复杂度是（nlogn);

这道题dp的思想是遍历整个数组，从当前的数往前找，遍历完后取最大值就可以了

```
for(int i=0; i<n; i++){
	for(int j=0; j<i; j++){
		if(nums[i] > nums[j]){
			dp[i] = max(dp[i],dp[j]+1);
		}
	}
	ans = max(ans,dp[i]);
}
```

贪心加二分的思想是**因为要尽量长的子序列，所以就要使子序列尽量慢的增长**

定义一个数组d[N],d[i]表示递增子序列长度为i时，末尾数的最小值。

例如：：数组 `1,2,3,4,5,6`中长度为3的上升子序列可以为 `1,2,3`也可以为 `2,3,4`等等但是`d[3]=3`，即长度为3时，子序列末尾元素最小为3

```
for(int i=1; i<n; i++){
	if(d[len] < nums[i]){
		d[++len] = nums[i];
	}
	else{
		int l = 1,r = len,pos = 0;
		while(l <= r){
			int mid = (l + r) / 2;
			if(d[mid] > nums[i]){
				r = mid - 1;
			}
			else{
				l = mid + 1;
				pos = mid; 
			}
		}
		d[pos+1] = nums[i];
	}
}
//	pos的作用是定位比nums[i]的数；
```

# 5-5

典中典，经典dp问题，网上很多讲的很好的，大致就是找到转移方程然后实现就好，有一些小优化，可以去洛谷翻一下