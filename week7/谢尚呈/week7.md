### **7-1 词典**

这一题是相当厚道了~~（比起下面的某一道或两道题可真是厚道到家了）~~，没有坑，数据规模小

开个`string`数组作词典，对于每个外语单词都检查词典内是否有翻译，有就输出翻译，没有就输出`"eh"`就可以了。

### **7-2 神秘密码**

运用递归可以解决这个问题。

基本思路是每遇见一个`[`，要查找其匹配的]的位置，并记录其中是否有另外成对的`[]`，如果有还要把第一个另外成对的[的位置记录下来，从这个`[`开始递归。

[的下一个位置一定是数字，这数字的下一个位置还有可能是一个数字~~【坑】~~，数字大小是1-99

递归第一个遇见的[完毕之后，直接按照数字指示的复制次数，将一开始遇见的[及与之相匹配的]之间的字符复制。虽然我们只是递归第一个成对的[]，但是无须担心出现诸如`[2A[3B][3C]]`这样的情况。因为我们目前仅仅枚举到第一个出现的`[`，虽然只展开了`3B`的部分，待我们枚举到`3C`的[时还是会进行展开操作

那么，如此把整个字符串遍历完之后，我们就完成了展开·解码的操作

~~别忘了把第一个`[`之后递归之前的字符加进去，比如不要漏掉上面例子中的`A`~~

### **7-3 删除公共字符**

这题仅仅使用string的函数就能简单完成，逐个匹配就好了

值得注意的是输入是一行作单位

~~一定要看清输入格式，输入是有多组的，别傻乎乎调试了半个小时才注意到这一点*1~~

### **7-4 最长有序子序列**

记忆化搜索的问题，应该属于动态规划

开除了记录输入序列之外的另一个数组，从第一个数字开始，记录“自第一个数字开始若是包含这个数字则最长的有序子序列可以有多长”这一数据，具体方法是

·若是第一个数，这个数据是1（第一个数前面不会有数字，它就是第一个数字）

·从这一个数字的前一个数字开始直到反向枚举回第一个数字结束，若是那个数字比这个数字小，记录那个数字的这个数据

·从诸记录中选出最大的数据，则这个数字的这个数据就是那个最大数据+1，也就是把这个数字添加到直至这个数字为止这个数字所能添加的诸有序子序列中最长的一条

那么每个数字的这个数据中最大者就是这一题的答案了

### **7-5 0-1背包问题**

是的，动态规划的经典入门问题

我采用的是记忆化搜索代替状态转移方程的方法，因为状态转移方程对我来说实在是阴影

~~就是因为状态转移方程难啃才一直学不会动态规划的，我好希望我看的书都是人话写的，里面的任何一个出现的概念都能解释的明明白白的~~

用一个二维数组`int max_v[num][bag_left]`来记录当搜索到第`num`件物品，且背包容量仅剩余`bag_left`时的最好情况，当然分“放入这件物品”和“不放入这件物品”来搜索

对于这种组数不确定的问题，建议是使用`while(cin>>...)`而不是`while(scanf("%...", &...))`，因为后者的结束条件是真的迷惑。我花了半个晚上一个小时的时间，把洛谷上例程修改成适合这道题的输入形式却提示“运行超时”而不是提示如同我自己写的代码的“答案错误”的代码中所有变量名，间隔符号全部改成和我自己的代码一模一样之后才发现，原来“运行超时”是采用`scanf("%...", &...)`而一直没有结束输入也就没有结束程序的锅。

那么为什么我自己的程序会答案错误呢？

因为输入格式是先输入完所有物品的重量，再输入完所有物品的价值

~~而我看成了依次输入每件物品的重量和价值再输入下一件物品，一定要看清输入格式，别傻乎乎调试了半个小时才注意到这一点*2~~

~~输入样例居然在这种离谱的情况下还能保持结果正确，让我不禁担心出题人下限的同时敬佩出题人的脑回路~~