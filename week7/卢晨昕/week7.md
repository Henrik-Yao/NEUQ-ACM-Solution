# **week7**

## **7-1**

考查哈希，当然可以自己手打哈希，但STL的map它不香吗？

map<string,string>p;记录该外语单词对应的单词
map<string,int>pp;记录该外语单词是否在字典中

然后遍历输出即可

时间复杂度为O(m)~~显然~~

## **7-2**

运用递归可以处理[]内的[]（比如[3[3asd]]）

函数dfs(a,i,now)表示**i->now**之间的压缩段解压缩之后的字符串，a[i]为第一次遇到的 **[** ,a[now]为与前边 **[** 数量匹配的最后一个 **]** .

即遇到当前第一个 **[** 时进行如下操作：

~~~cpp
if(a[i]=='[')
{
	int now=i+1;
	int t=1;
	while(now<len&&t)
	{
		if(a[now]=='[')t++;
		else if(a[now]==']')t--;
		if(t==0)break;
		now++;
	}
	cout<<dfs(a,i,now);
	i=now;
}
~~~

在dfs中我们进行判断，分为中间包含有压缩和没压缩两种，如果有压缩则递归处理直到没有压缩即可

对于没有压缩的一段，直接遍历记录输出即可。



## **7-3**

没什么好说的，字符的哈希值直接记录为它的ASCII码即可，然后遍历判断输出。



## **7-4**

线性DP

**O(n^2)做法**

f[i]表示前i个数字的最长上升子序列的长度，

则递推公式为：

f[i]=max(f[i],f[j]+1)  (a[j]<a[i],j<i)

如果当前的a[i]比a[j]大，说明它可以作为前j个数字的最长上升子序列的下一个上升数字，则比较f[i]与f[j]+1即可

**O(nlogn)做法**

f[i]表示长度为i的最长上升子序列的最小结尾数，

len表示当前的最长单调序列长度

根据定义，f数组一定是单调递增的



如果当前a[i]大于f[len]那么说明a[i]可以当作下一个元素，即f[++len]=a[i];

如果a[i]小于等于f[len]，那么运用贪心的思想，当前的结尾元素越小，后边的数字能接上的几率就越大，所以，二分查找f中最后一个小于等于a[i]位置p，更新f[p]=min(b[i],f[p]);



最后len即为答案



## **7-5**

经典永流传，01背包

~~~cpp
for(int i=1;i<=n;i++)
{
	for(int j=c;j>=w[i];j--)
	{
		if(f[j-w[i]]+v[i]>f[j])f[j]=f[j-w[i]]+v[i];
	}
}
~~~

f[i]表示使用i空间后的最大价值