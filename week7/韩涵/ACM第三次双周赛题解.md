# ACM第三次双周赛题解&动态规划

## 第三次双周赛题解

为啥测试样例还会超时呀，代码又不是死循环。。。（虽然时间复杂度确实挺高）

### 7-1 词典

###### 题目详情：

你刚从滑铁卢搬到了一个大城市，这里的人们讲一种难以理解的外语方言。幸运的是，你有一本字典来帮助你理解它们。

###### 输入格式:

输入第一行是正整数N和M,后面是N行字典条目（最多10000条），然后是M行要翻译的外语单词（最多10000个）。每一个字典条目都包含一个英语单词，后面跟着一个空格和一个外语单词。 输入中的每个单词都由最多10个小写字母组成。

###### 输出格式:

输出翻译后的英文单词，每行一个单词。非词典中的外来词汇输出“eh”。

###### 解题思路：

结构体内string存储字符串，暴力逐个筛查即可。（滑铁卢在暗示神魔）

###### c++代码：

```c++
#include<iostream>
using namespace std;

typedef struct dictionary {
    string word;
    string translation;
};

dictionary dic[100001];
string need;
int a, b;

void translate() {
    for (int i = 0; i < a; i++) {//逐个暴力匹配
        if (need == dic[i].translation) {
            cout << dic[i].word << endl;
            return;
        }
    }
    cout << "eh" << endl;
}

int main() {
    cin >> a >> b;
    for (int i = 0; i < a; i++) cin >> dic[i].word >> dic[i].translation;
    while (b--) {
        cin >> need;
        translate();
    }
}
```

### 7-2 神秘密码

堆栈？哈希? 花里胡哨的。接受一个处理一个就行了。

###### 题目详情：

传说二战时X国收到了上帝的一串密码，只有解开密码，才能阻止战争的继续进行，世界才会恢复和平。解开密码的第一道工序就是解压缩密码，上帝对于连续的若干个相同的子串"X"会压缩为"[DX]"的形式(D是一个整数且1<=D<=99),比如说字符串"CBCBCBCB"就压缩为"[4CB]"或者"[2[2CB]]",类似于后面这种压缩之后再压缩的称为二重压缩。如果是"[2[2[2CB]]]"则是三重的。现在我们给你上帝发送的密码，请你对其进行解压缩。

###### 输入格式:

一个字符串

###### 输出格式:

一个字符串

###### 解题思路：

巧妙的规定输入的数据类型，再进行简单的递归操作即可。使用返回值为string的函数会更加方便。

（代码非本人原创，转自DJL同学）代码很巧妙，不需要什么注释。

###### c++代码：

```c++
#include<iostream>
using namespace std;

string func()
{
    string s = "", schild;
    int n;
    char ch;
    while (cin >> ch) {
        if (ch == '[') {
            cin >> n;
            schild = func();
            while (n--) s += schild;
        }
        else {
            if (ch == ']') return s;
            else s += ch;
        }
    }
}

int main()
{
    cout << func();
    return 0;
}
```

### 7-3 删除公共字符 

充分利用数组下标是关键。输入挺j的。

###### 题目详情：

7-3 删除公共字符 

输入两个字符串，从第一个字符串中删除第二个字符串中的所有字符。例如，输入“They are students.”和“aeiou”，则删除之后的第一个字符串变成“Thy r stdnts”。

###### 输入格式:

输入包含多组测试，每个测试输入包含两个字符串。

###### 输出格式:

输出删除后的字符串。

###### 解题思路：

将第二个字符串的ASCLL码向某一已经初始化int数组匹配，对应下标的位置加一。之后检验输出的每一位对应的int数组ASCLL值是否为零，为零就输出。

###### c++代码：

```c++
#include<iostream>
#include<string>

using namespace std;

int main()
{
    string str1, str2;
    while (getline(cin, str1)) {
        getline(cin, str2);
        int hashtable[256] = { 0 };
        //充分利用下标
        for (int i = 0; i < str2.size(); ++i) hashtable[str2[i]]++;
        string ret;
        for (int i = 0; i < str1.size(); ++i)
        {
            //直接输出容易出错
            if (hashtable[str1[i]] == 0)
                ret += str1[i];
        }
        cout << ret << endl;
    }
}
```




## 动态规划

有一类活动的过程，由于它的特殊性，可将过程分成若干个互相联系的阶段，在它的每一阶段都需要作出决策，从而使整个过程达到最好的活动效果。因此各个阶段决策的选取不能任意确定，它依赖于当前面临的状态，又影响以后的发展。当各个阶段决策确定后，就组成一个决策序列，因而也就确定了整个过程的一条活动路线．这种把一个问题看作是一个前后关联具有链状结构的多阶段过程就称为多阶段决策过程，这种问题称为多阶段决策问题。在多阶段决策问题中，各个阶段采取的决策，一般来说是与时间有关的，决策依赖于当前状态，又随即引起状态的转移，一个决策序列就是在变化的状态中产生出来的，故有“动态”的含义，称这种解决多阶段决策最优化的过程为动态规划方法。



动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。

### 7-4 最长有序子序列

注意输出格式。

###### 题目详情：

对于给定一个数字序列 (a1，a2，…，an) ，如果满足a1<a2<…<an，则称该序列是有序的。若在序列(a1，a2，…，an) 中删除若干元素得到的子序列是有序的，则称该子序列为一个有序子序列。有序子序列中长度最大的即为最长有序子序列。例如，(1，3，5)、(3，5，8)、(1，3，5，9)等都是序列 (1，7，3，5，9，4，8) 的有序子序列；而(1，3，5，9)、(1，3，5，8)、(1，3，4，8)都是序列 (1，7，3，5，9，4，8)的一个最长有序子序列，长度为4。请编写程序，求出给定数字序列中的最长有序子序列的长度。

###### 输入格式:

首先输入一个正整数T，表示测试数据的组数，然后是T组测试数据。每组测试数据第一行输入一个整数 n（1≤n≤1000），第二行输入n个整数，数据范围都在[0，10000]，数据之间以一个空格分隔。

###### 输出格式:

对于每组测试，输出n个整数所构成序列的最长有序子序列的长度。每两组测试的输出之间留一个空行。

###### 解题思路：

动态规划，计算 i 个数的最长子序列时将前 i - 1 个数的最长子序列长度求出，在将第 i 个元素和 i - 1 个元素大小比较，大则在此基础上 +1， 小则为一。（防止同一最长序列长度重复存储，计算前 i 个数的最长子序列长度时序列必须取第 i 个元素。具体见代码。

###### c++代码：

```c++
#include<iostream>
using namespace std;

int longest[1005] = {0};//最长字段长度
int num[1005] = {0};//序列

int main(){
    int t;
    cin>>t;
    int m = t;
    while(m--){
        if(m != t - 1) cout<<endl;//注意输出
        int len;
        int ans = 1;
        cin>>len;
        num[0] = -1;//注意数据范围
        for(int i = 1;i <= len;i++) cin>> num[i];
        for(int i = 1;i <= len;i++){
            for(int j = 0;j < i;j++){
                if(num[i] > num[j]) //计算并存储前i个元素的最长序列列
                    longest[i] = longest[i] > longest[j] + 1 ? longest[i] : longest[j] + 1;
            }
            ans = ans > longest[i] ? ans: longest[i];
        }
        cout<<ans<<endl;
        for(int i = 1;i <= len;i++) longest[i] = 0;
    }
}
```

### 7-5 0-1 背包问题 

最简单的背包问题，评价的没有。

###### 题目详情：

给定n种物品（每种仅一个）和一个容量为c的背包，要求选择物品装入背包，使得装入背包中物品的总价值最大。

###### 输入格式:

测试数据有多组，处理到文件尾。每组测试数据输入3行，第1行为两个整数n（1≤n≤400）和c (1≤c≤1500)，分别表示物品数量与背包容量，第二行为n个物品的重量wi（1≤i≤n），第三行为这n个物品的价值vi（1≤i≤n）。物品重量、价值都为整数。

###### 输出格式:

对于每组测试，在一行上输出一个整数，表示装入背包的最大总价值（结果保证在int范围内）。

###### 解题思路：

将每一个物品逐个放入，计算从零到c容量的背包的最大价值。商品放入后计算价值时使用容量和重量相减后的背包最大价值+该物品价值，且需要和原值比较。

###### c++代码：

```c++
#include<iostream>
using namespace std;

int bag[1505];//使用一维数组，将之前的无关内容进行覆盖即可
int weight[405];
int price[405];

int main() {
    int n, c;
    while (cin >> n >> c) {
        for (int i = 1; i <= n; i++) cin >> weight[i];
        for (int i = 1; i <= n; i++) cin >> price[i];
        for (int i = 0; i < n; i++) bag[i] = 0;
        for (int i = 1; i <= n; i++) {
            for (int j = c; j >= weight[i]; j--) {//计算最大容量
                bag[j] = bag[j] > bag[j - weight[i]] + price[i] ? bag[j] : bag[j - weight[i]] + price[i];
            }
        }
        int ans = bag[c];
        cout << ans << endl;
        for (int i = 0; i <= c; i++) bag[i] = 0;//初始化
    }

}
```

