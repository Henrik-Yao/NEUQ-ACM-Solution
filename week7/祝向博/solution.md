# 词典
map的简单应用

# 神秘密码
我用栈写的，遇到“[”压栈，遇到“]”出栈

# 删除公共字符
简单的字符串处理，值得注意的是这玩意多组数据qwq

# 最长有序子序列

很经典的dp

O(N^2)的做法就是f[i]=max{f[j]}+1,满足j<i&&a[j]<a[i]

这题还有O(NlogN) 的做法

定义一个 f 数组

f[i]表示，长度为i的有序子序列，最后一个元素最小为几

用变量len来表示最长有序子序列

对于 a[i] 来说有两种情况：

**1: a[i]>f[len]**  显然，a[i]可以作为长度为len+1的有序子序列的最后的值，f[++len]=a[i]即可

**2： a[i]<=f[len]** 这个时候a[i]无法更新len的值，但可以刷新f数组的值。显而易见，f数组中的值越小，最终的长度可能就越长。我们找到f数组中大于等于a[i]的最小的那个f[j],令f[j]=a[i]。即到i为止，长度为j的有序数列的最后一个元素最小的值为a[i]
f显然单调，所以可以二分查找。

# 01背包

经典的dp，f[i][j]=max{f[i-1][j-w[i]]+v[i],f[i-1][j]}
因为方程只与j有关，可以用一维数组存储状态
