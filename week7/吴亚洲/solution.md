# solution

## **7-1 词典**

每个字符串对应唯一一个字符串，很明显这题要用map，map可以保存任意相同类型变量的一一对应关系，map的定义：`map<string,string> match;`代表定义名为match的map；map的赋值：`match[i]=j;`代表与i对应的为j；map中的查找：`match.find(x)==match.end()`代表未找到与x对应的值，否则，`match.find(x)->second`就代表与x对应的那个值。

## **7-2 神秘密码**

这是一道递归题（后来才知道），代码不算复杂应该能看得懂，令我大为震惊的是竟然可以在读入字符的同时读入1-2位的整形数字。。

## **7-3 删除公共字符**

用了桶的思想（之后看题解好像map也可以做），定义一个数组judge，循环第二个字符串，对于字符串中的每个字符x，`judge[x]++；`，然后循环过一遍第一个字符串，对于每个字符y，如果judge[y]>0，就说明在第二个字符串里出现过，把没出现过的记录下来最后输出就ok了。

## **7-4 最长有序子序列**

数组a[i]记录第i个数字的值，定义一个数组f，f[x]代表以第x个数字结尾的最长子序列长度。那么f[x]就等于在x之前的满足a[y]<a[x]的f[y]的最大值再加一，即：

`fo`r(int y=0;y<x;y++)`
			`{`
				`if(a[y]<a[x])`
				`Max=max(f[y],Mmax);`
			`}`
			f[x]=_max+1;`

最后取f[i]的最大值输出。

## **7-5 0-1背包问题**

我刚开始学dp，就用了最简单朴实的二维背包法，大致思路是：定义一个二维数组`f[i][j]`，代表前i件物品在容量为j的背包里的最大价值，对于每件物品，如果w[i]>j，说明背包中放不下第i件物品了，的状态转移方程为：`f[i][j]=f[i-1][j]` 否则状态转移方程为：`f[i][j]=max(f[i][j],f[i-1][j-w[i]]+v[i]);`，最后找所有`f[i][j]`的最大值输出即可。