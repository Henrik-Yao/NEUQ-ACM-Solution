# contest 3

## 7-1 词典

> 使用 `map` 映射即可，每次使用 `count` 判断是否存在

## 7-2 神秘密码

> 对于每一个环节：读入字符 `ch`
>
> 如果读入 `[` ，则读入 `n` ，然后递归，将递归得到的结果 `n` 次拼接给 `s`
>
> 否则，如果读入 `]` ，返回 `s`
>
> ​			否则，`s += ch`

```c++
#include <bits/stdc++.h>
using namespace std;
string func()
{
    string s = "", s1;
    int n;
    char ch;
    while (cin >> ch) {
        if (ch == '[') {
            cin >> n;
            s1 = func();
            while (n--) s += s1;
        } else {
            if (ch == ']') return s;
            else s += ch;
        }
    }
}
int main()
{
    cout << func();
    return 0;
}
```

## 7-3 删除公共字符

> **多组输入**， 每次读入将第二个字符串的每个字符存入 `map` 或者 `set` 中， 在遍历第一个字符串，如果字符在 `map` 或 `set` 中存在时跳过，不存在则存入 `vector` 中。输出

## 7-4 最长有序子序列

* 状态表示

  > `f[i]` 表示以 `q[i]` 为结尾的最长有序子序列长度

* 状态计算

  > `f[i] = max(f[j + 1], f[i])` (`1 <= j <= i`)

* 时间复杂度

  O(n ^ 2)

## 7-5 0-1背包问题

> 0-1 背包重要的是确定状态如何表示，以及状态如何计算。

* 状态表示

  > `f[i][j]` 表示 前 `i` 个物品总价值不超过 `j` 的总价值最大值。
  >
  > `v[i]` 表示第 `i` 个物品所占容量，`w[i]` 表示第 `i` 个物品价值

* 状态计算

  > 选第 `i` 个物品时，`f[i][j] = f[i - 1][j - v[i]] + w[i]`
  >
  > 不选第 `i` 个物品时，`f[i][j] = f[i - 1][j]`
  >
  > 综上：`f[i][j] = max(选, 不选)`
  >
  > `ans = f[n][m]` `n` 表示物品个数，`m` 表示容量最大值

* 时间复杂度

  O(n * m)