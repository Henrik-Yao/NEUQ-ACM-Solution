# 7-1
可以用map映射解决
# 7-2
考虑递归处理：
思路{
    读到“[”时，读入必定存在的后一个数字
    然后自我调用函数 用temp存 后面的字符 再根据读入的数字存
    读到“]”就返回答案
    以上两者都不满足，证明在自我调用读入字符
}
用char ch；while（ch=getchar（））的话一定注意，此处会超时，
因为这里ch读不到文件结束符EOF
要写成 
int tch；
char ch；
while（（tch=getchar（））！=EOF）{
ch =tch；
......
}
# 7-3
建立一个vst函数标记要删除的字符
在输出时进行判断是否标记了
# 7-4
dp
注意此处dp存的是以  当下这个数结尾  的最长上升子序列
有次每一次就往前搜寻最大的那个子序列+1 就是当下的最长子序列
然后最少子序列也是有1的
（代码中ans+1在于前面初始化为0而没有初始成1）
# 7-5
01背包问题
我应该是最low的解法了
建一个二维数组：表示装第i个物品且此时容积是j时，背包的最大价值
然后每一个 i 先继承同等j容量下 
已经判断好了的是否装第i-1个物品时的背包最大价值
随后进行状态转移方程   判断装与不装当下的物品

不装就不变，装入的话就不是继承当下的那个价值加   而是继承装i-1个物品且容积为j-（现物品体积或者重量）时的价值+此物品价值

复杂度是n的c次方
