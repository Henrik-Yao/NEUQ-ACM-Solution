# 题解
## 7.1 词典
     使用两个map映射M,Q, M用来保存这个单词是否在字典中，Q用来保存翻译后的单词，存一个单词a后，M[a]=1代表存过了，Q[a]=翻译后的结果，输入单词b时先判断M[b]是否为1，不是的话代表没存过，输出eh，是的话用Q输出对应答案。
## 7.2神秘密码
    此题用递归实现比较好，声明一个总的字符串，然后一个字符一个字符的输入，如果遇到[，就代表遇到压缩的了，需要解压缩，就先输入次数，然后开始递归，把递归后输入的字符的相应倍数加到总串上；如果遇到正常的字符就直接加到总串上；如果遇到]，就代表这次输入已经结束了，应该停止，返回总串即可。
## 7.3删除公共字符
     用一个map映射，把所有第二个字符串中的字符都标记一下 比如map<char,int>Q,Q[c]=1;代表已经存在，然后对第一个字符串中的所有字符一个一个进行判断，输出所有不存在的，即map后值不是1的字符即可。
## 7.4最长有序子序列
     此题是基础的动态规划，dp[i]表示以a[i]结尾的最长递增子序列的长度，用一个二重循环开始遍历，j从0遍历到i-1，如果a[j]<a[i]就代表a[i]可以放到a[j]代表的子序列的后面，所以a[i]代表的序列长度就至少要为a[j]+1,不断取较大值就行。
## 7.5 01背包问题
      经典的0 1背包问题，动态规划思维。每个物品有两个状态，放入，或者不放入，遍历所有物品，dp[i][j]表示进行到物品i时，背包容量为j时能获取的最大价值；循环中判断为 如果j大于物品的质量，就代表能放下，此时可以放，也可以不放，所以要进行判断，dp[i][j]=max(dp[i-1][j],dp[i][j-w[i]]+v[i]),分别对应放与不放两种情况，对i和j遍历一下即可。