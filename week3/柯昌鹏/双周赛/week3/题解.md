# 题解

## 1.**最大子段和**

> 给定n个整数（可能为负数）组成的序列a[1],a[2],a[3],…,a[n]，求该序列如a[i]+a[i+1]+…+a[j]的子段和的最大值。当所给的整数均为负数时，定义子段和为0。
>
> 要求算法的时间复杂度为O(n)。

思路：首先这可以是一个dp的题目，就需要找到状态转移方程，边界和子结构。对于这题，首先要求的子段和是最大且连续，需要考虑的就是要在什么时候开始取一个新的区间。那么从第一二项开始分析：第一项本身就是第一个状态的值，然后第二项加入，

> 样例：
>
> 6
> -2 11 -4 13 -5 -2

-2输入，那么假设这个状态为dp[1]，那么dp[1]=-2‘

然后加入了11，因为11+dp[1]<11 所以另取一个区间边界 dp[2]=11

加入-4，因为dp[2]-4>-4,对于-4这个数而言，这个状态是更优的，所以dp[3]=7

以此类推，

最后拿所有的dp[n]状态方程相比较，大的输出

如果到最后状态方程都小于零，根据题目就直接输出零就行

## 2.汉诺塔问题

> 这个是之前的原题，就是把整个过程反过来看，在最后一步是从a到c
>
> 前一步就是把n-1块借助a从b移到c
>
> 再前一步就是把n-1块借助c移到b
>
> 这样的三步就可以表示三柱汉诺塔的移动过程，用递归可以求解

## 3.汉诺塔3

> 这题主要就是找到移动步数之间的关系，可以从前两组数据分析
>
> 可以得到规律为f[n]=3*f[n-1]+2,然后直接递归求解，不过要注意数据的大小，容易出现段错误

## 4.汉诺塔2

> 四柱汉诺塔的一个最小步数问题，最小步数为：min{2*f[i]+pow(2,n-i)}
>
> 求出步数之后递归求解
>
> 更详细的思路：[(47条消息) 四柱汉诺塔_LzyRapX-CSDN博客_四柱汉诺塔](https://blog.csdn.net/liangzhaoyang1/article/details/50756412)
>
> [(47条消息) 算法：四柱汉诺塔_顾道长生的知识库-CSDN博客_四柱汉诺塔](https://blog.csdn.net/wl1780852311/article/details/100326304)

## 5.简单的归并

> 就是将两组数据合并之后归并排序再输出

## 6.字符串的全排列

> 这里使用的是stl中的next_permunation函数，可以实现自动的全排列，但是在使用前要将字符串提前排好序
>
> 

## 7. 逆序对

>  sysmalloc: Assertion `(old_top == initial_top (av) && old_size == 0) || ((unsigned long) (old_size) >= MINSIZE && prev_inuse (old_top) && ((unsigned long) old_end & (pagesize - 1)) == 0)' failed   第一次遇到运行时错误，泪目
>
> 具体思路就是归并排序的小改款，就在原来的归并排序里面加上一个逆序对的计数器，然后在归并的过程中就可以得到逆序对的数量。

## 8.二分查找

> 这里也是使用stl中的lower_bound函数来实现自动的二分查找，同样的，使用前需要给字符串排好序