#最大子段和从头开始扫描这个线性数组，扫描到一个数的时候，考虑当前位的数字加入这个子段时候会对子段和有什么贡献。如果加上当前位的会使得子段和变大，那么就更新答案，反之就不更新。#汉诺塔问题I之前的题解里已经说过了，这里不再赘述#汉诺塔问题III问题III比问题II要简单，主要是因为III可以打表找规律：*ans[i] = 3 a[i-1]+2*我用的是滚动数组递推，因为n最大是35，所以也不会很慢。就是要注意开unsigned long long#汉诺塔问题II这是一个dp？首先考虑汉诺塔I问题，当柱子只有三根的时候，手动模拟一下可以发现： *f[i] = 2f[i-1]+1* 现在我们手动模拟一下四根柱子的情况~~（考试的时候我手动模拟模拟着模拟着睡着了）~~，会发现当移动一个圆盘的时候，会面临两个选择，要么是按照原来三根柱子的规则来移动，要么是放置到那根新添加的柱子上。考虑dp：设dp[i]是移动到第i个圆盘的时候最少的步数。f[i]是有三根柱子的时候的步数，需要预先处理。那么根据刚才的发现，每一步的决策有两个选择：1）按照原来三根柱子的规则来2）按照新的决策来所以转移方程:>dp[i] = min(dp[i], 2*dp[j]+f[i-j]);#简单的归并~~我们把这个两个数组看做是长度为m+n的一个长数组然后sort就好了~~#字符串的全排列就是用dfs来输出全排列~~当然next_permutation就完事了~~然后别忘了没有special judge，需要按照字典序输出。这样的话把每个排列记录下来然后写一个带cmp的sort就行了#逆序对用归并排序的思想，考虑每插入一个数的时候，就会跟前面所有比它大的数都构成逆序对。所以只需要在归并的过程中计算即可#二分查找就是二分查找的模板题吧，别忘了特判输出-1的情况就行