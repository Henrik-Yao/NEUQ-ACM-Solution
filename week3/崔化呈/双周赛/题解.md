# week3 双周赛 题解
## 最大子段和	
	采用分治的思想，每部分从左侧、中间与右侧三者选最大，最后得到的结果即是整个部分的最大

	#include<bits/stdc++.h>
	using namespace std;
	const int minn=-1234556666;
	int n,arr[201000];
	int max(int a,int b)
	{
		return a>b?a:b;  //无关
	}
	int fen(int l,int r)
	{
		if(l==r)
		{
			return arr[l];
		}
		else{}
		int mid=(l+r)>>1;
		int sum=0,re1=minn,re2=minn;
		for(int i=mid;i>=l;i--)   //一定要从mid开始往左计算
		{
			sum+=arr[i];
			re1=max(sum,re1);
		}
		sum=0;
		for(int i=mid+1;i<=r;i++) //从mid+1开始往右计算
		{
			sum+=arr[i];
			re2=max(re2,sum);
		}
		return max(max(fen(l,mid),fen(mid+1,r)),re1+re2);  //每部分都是通过从右侧，左侧以及中间值中选的最大值得到

	}
	int main()
	{
	    int flag=0;
		cin>>n;
		for(int i=1;i<=n;i++)
		{
			scanf("%d",&arr[i]);
		if(arr[i]>=0){flag=1;}
		}
	    if(flag){cout<<fen(1,n)<<endl;}
	    else{cout<<0<<endl;}

	return 0;
	}

## 汉诺塔问题
	经典递归问题
	#include<bits/stdc++.h>
	using namespace std;
	void hnt(int n,string a,string b,string c)
	{
		if(n==1){cout<<a<<"->"<<c<<endl;}
		else
		{
			hnt(n-1,a,c,b);
			cout<<a<<"->"<<c<<endl;
			hnt(n-1,b,a,c);
		}
	}
	int main()
	{
		int n;
		string a,b,c;
		cin>>n>>a>>b>>c;
		hnt(n,a,b,c);
		return 0;

	}

## 汉诺塔Ⅲ
~~这就是dalao的思想吗，orz~~

	n个盘子的移动过程可拆解为以下步骤：   移动次数f（n）
	1.将n-1个小盘子移动至c柱（整体思想）   f（n-1）
	2.将最大的盘子移动至b柱					1
	3.再将n-1个小盘子移动至a柱（整体思想）  f（n-1）
	4.最大的成功到达c柱						1
	5.将n-1个小盘子成功到达c柱（整体思想）  f（n-1）
	将递归的主体当作整体来想，并以此作为上一层递归的一个步骤来考虑。
	#include<bits/stdc++.h>
	using namespace std;
	int main()
	{
		long long f[40];
		int n;
		f[1]=2;
		for(int i=2;i<=40;i++)
		{
			f[i]=f[i-1]+1+f[i-1]+1+f[i-1];
		}
		while(cin>>n)
		{
			cout<<f[n]<<endl;
		}
		return 0;

	}

## 汉诺塔Ⅱ
~~又一次领会dalao的思想，orz~~
		
	4个柱移动过程分解：
	1.将j个盘子移动到b柱（4个柱可用）
	2.将（i-j）个盘子移动到c柱（3个柱可用，3柱模式，转化为熟悉的情况）
	3.再将j个盘子移动到c柱（4个柱可用）
	具体j为几时所用步骤最少呢？这就让计算机去找不同整体盘的不同情况吧。
	#include<bits/stdc++.h>
	using namespace std;
	int n;
	unsigned long long three[70],four[70];  //unsigned必须写

	int main()
	{
		three[1]=1;
		memset(four,0x7fffffff,sizeof(four));
	    four[1]=1;
				for(int i=2;i<70;i++)
				{
					three[i]=2*three[i-1]+1;
				}
				for(int i=2;i<70;i++)
				{
					for(int j=1;j<i;j++)
					{
						four[i]=min(four[i],four[j]+four[j]+three[i-j]);   //让计算机去找吧
					}
				}
		while(cin>>n)
		{
					cout<<four[n]<<endl;
		}
		return 0;
	}
## 简单的归并
归并排序板子

	#include<bits/stdc++.h>
	using namespace std;
	void mergesort(int arr[],int l,int mid,int r)
	{
		int t[r-l+1];
		int li=l,ri=mid+1;
		int i=0;
		while(li<=mid&&ri<=r)
		{
			t[i++]=arr[li]<arr[ri]?arr[li++]:arr[ri++];
		}
		while(li<=mid)
		{
			t[i++]=arr[li++];
		}
		while(ri<=r)
		{
			t[i++]=arr[ri++];
		}
		for(int j=0;j<r-l+1;j++)
		{
			arr[l+j]=t[j];
		}
	}
	void merge(int arr[],int l,int r)
	{
		if(l==r){return;}
		else
		{
			int mid=(l+r)>>1;
			merge(arr,l,mid);
			merge(arr,mid+1,r);
			mergesort(arr,l,mid,r);
		}
	}
	int main()
	{
		int T,m,n,a[220];
		cin>>T;
		for(int i=0;i<T;i++)
		{
			cin>>m;
			for(int j=0;j<m;j++)
			{
				cin>>a[j];
			}
			cin>>n;
			for(int j=m;j<m+n;j++)
			{
				cin>>a[j];
			}
			merge(a,0,m+n-1);
			for(int j=0;j<m+n-1;j++)
			{
				cout<<a[j]<<" ";
			}
		cout<<a[m+n-1]<<endl;
		}
		return 0;

	}

## 字符串的全排列
dfs板子

	#include<bits/stdc++.h>
	using namespace std;
	bool exist[10];
	char a[10],b[10];
	bool cmp(char a,char b)
	{
		return a<b;
	}
	void dfs(int len)
	{
		if(len==strlen(a))
		{
			for(int i=0;i<len;i++)
			{
				cout<<b[i];
			}
			cout<<endl;
			return;
		}
		for(int i=0;i<strlen(a);i++)
		{
			if(exist[i]==0)
			{
				exist[i]=1;
				b[len]=a[i];
				dfs(len+1);
				exist[i]=0;
			}
		}
	}
	int main()
	{
		cin>>a;
		int slen=strlen(a); 
		sort(a,a+slen,cmp);
		dfs(0);
		return 0;

	}
## 逆序对
用归并排序加个计数君

	#include<bits/stdc++.h>
	using namespace std;
	int a[1001000];
	int t[1001000];
	long long ans=0,n;
	void mergesort(int arr[],int l,int mid,int r)
	{
		int i=l,li=l,ri=mid+1;
		while(li<=mid&&ri<=r)
		{
			if(arr[li]<=arr[ri])
			{
				t[i++]=arr[li++];
			}
			else
			{
				t[i++]=arr[ri++];
				ans+=mid-li+1;			//右边的序列已经从小到大排好了，说明当前的右边的值比左边的剩下的都小，即逆序对为mid-left+1
			}
		}
		while(li<=mid)
		{
			t[i++]=arr[li++];
		}
		while(ri<=r)
		{
			t[i++]=arr[ri++];
		}
		for(int j=l;j<=r;j++)
		{
			arr[j]=t[j];
		}
	}
	void merge(int arr[],int l,int r)
	{
		if(l==r){return;}
		int mid=(l+r)/2;
		merge(arr,l,mid);
		merge(arr,mid+1,r);
		mergesort(arr,l,mid,r);
	}
	int main()
	{
		cin>>n;
		for(int i=1;i<=n;i++)
		{
			cin>>a[i];
		}
		merge(a,1,n);
		cout<<ans;
		return 0;

	}

## 二分查找
方法如题名

	#include<bits/stdc++.h>
	using namespace std;
	int n,x,wei;
	int a[1001000];

	int erfen(int l,int r,int g)
	{
		while(l<=r)
		{
			int mid=(l+r)>>1;
			if(g>a[mid])
			{
				l=mid+1;
			}
			else
			{
				r=mid-1;
			}
		}
		return l;
	}
	int main()
	{
		cin>>n>>x;
		for(int i=1;i<=n;i++)
		{
			scanf("%d",&a[i]);
		}
		wei=erfen(1,n,x);
		cout<<wei<<endl;
		return 0;
	}
