双周赛题解

1.最大子段和

要求算法的时间复杂度为O(n)。所以我们选择DP。

dp[i]数组表示以i结尾的子段的最大值

考虑：如果第i个元素前面的以第i-1元素结尾的子段和dp[i-1]为负数，则不如不要前面的所有元素

所以可得方程 dp[i]=max(dp[i-1]+a[i],a[i]);

对于每个下标再取一次max即可。

ans=max(dp[i],ans);





2，经典问题，模拟即可，递归问题。





3，递归公式： hnt(n-1)*3+2;

注意给hnt 0,1赋值。





4，有两种状态（移法）：1，借用其他两个柱子将圆盘移到目标位置；

2，和之前一样只有一根过度柱子移动圆盘。

所以对于不同的移动个数取其中最优的即可。

枚举从1—n采用1方法，剩下的采用2.

ans=hn[j]*2+anss-1;
minn=min(ans,minn);

hn[i]=minn;

输出hn[n]；





5，水题，读入sort输出即可。





6，学习了一下C++的STL函数next_permutation；

使用该函数即可。





7，先写出归并排序的板子，然后考虑逆序对。

当我们交换a[i]和a[j]a时，计算逆序对。

对于每一次交换ans=mid-p+1;

最后输出ans即可。





C++STL lower_bound超级好用，或者可以写二分查找的板子。