# 4-1

## 题目

> 人类正在经历一场生化危机，许多城市已经被病毒侵袭，这些城市中的人们为了避免感染病毒，计划开车逃往其他没有被病毒入侵的城市（安全城市）。有些城市之间有公路直达，有些没有。虽然他们知道哪些城市是安全的，但是不知道有没有一条安全路径能够到达安全城市（只有该路径上经过的所有城市都是安全的，该路径才是安全路径）。请你编写一个程序帮助他们判断。

## 输入格式

> 输入第一行为三个正整数，分别表示所有城市个数m（m<=100）、安全城市个数n（m<=50）、公路个数k（k<=100）。随后一行给出n个安全城市的编号。随后k行，每一行给出两个整数，表示连接一条公路的两个城市编号。最后一行输入两个整数，分别表示当前所在城市s、目标城市d。每行整数之间都用空格分隔。

## 输出格式

> 若目标城市已被病毒入侵（非安全城市），输出"The city i is not safe!"；若目标城市为安全城市且从当前所在城市能够经过一条安全路径到达目标城市，输出"The city can arrive safely！"；若目标城市为安全城市但是从当前所在城市没有一条安全路径到达目标城市，输出"The city can not arrive safely！"，i为目标城市编号。

## 实现方法

应用BFS解题



# 4-2

## 题目

求从某个命题出发的所有推理路径都会将结论引导到同一个最终命题的路径个数

## 输入格式

> 输入首先在一行中给出两个正整数 *N*（1<*N*≤500）和 *M*，分别为命题个数和推理个数。这里我们假设命题从 1 到 *N* 编号。
>
> 接下来 *M* 行，每行给出一对命题之间的推理关系，即两个命题的编号 `S1 S2`，表示可以从 `S1` 推出 `S2`。题目保证任意两命题之间只存在最多一种推理关系，且任一命题不能循环自证（即从该命题出发推出该命题自己）。
>
> 最后一行给出待检验的两个命题的编号 `A B`。

## 输出格式

> 在一行中首先输出从 `A` 到 `B` 有多少种不同的推理路径，然后输出 `Yes` 如果推理是“逻辑自洽”的，或 `No` 如果不是。
>
> 题目保证输出数据不超过 10^9^。

## 实现方法

利用DFS+记忆化搜索实现



# 4-3

## 题目

扫雷游戏的模拟

## 输入格式

> 输入第一行是4个正整数*n*、*m*、*k*和*l*，其中*n*、*m*、*k*的含义如前所述。接下来*k*行，每行2个整数*i*和*j*，表示每个雷的坐标，即雷在第*i*行第*j*列的方格里。接下来*l*行，每行2个整数*i*和*j*，表示用户点击信息，即用户点击了第*i*行第*j*列的方格。*m*,*n*不超过20，*k*不超过50，*l*不超过200，0≤*i*<*n*，0≤*j*<*m*.

## 输出格式

> 对于用户的每个点击：（1）如果用户点击的方格是已被打开的方格，则点击无效，忽略该点击。（2）如果点击的方格是地雷，则输出“You lose”，程序退出；（3）如果点击的方格不是地雷，则输出点击后的游戏界面，即n行m列整数，每个整数后一个空格，此时若用户获胜，则再输出“You win”。注：对用户每个有效点击所输出的信息用一个空行间隔。

## 解题思路

先循环周围记录雷的个数，再对无雷的方格周围进行进一步搜索，直到方格与雷相邻。



# 4-4

## 题目

> 有一个仅由数字0与1组成的n*n格迷宫。若你位于一格0上，那么你可以移动到相邻4格中的某一格1上，同样若你位于一格1上，那么你可以移动到相邻4格中的某一格0上。
>
> 你的任务是：对于给定的迷宫，询问从某一格开始能移动到多少个格子（包含自身）。

## 输入格式

> 第1行为两个正整数n,m。
>
> 下面n行，每行n个字符，字符只可能是0或者1，字符之间没有空格。
>
> 接下来m行，每行2个用空格分隔的正整数i,j，对应了迷宫中第i行第j列的一个格子，询问从这一格开始能移动到多少格。 （n <= 1000, m <= 100000）

## 输出格式

> m行，对于每个询问输出相应答案。

## 解题思路

BFS+联通块标记，在每一次向外拓展时计数，两边通路一样，队列中有几个元素就有能移动多少块。
