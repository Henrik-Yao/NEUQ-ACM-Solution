#### T1

遍历1-n，设一个变量不断累加，如果加到某个值后小于0，则将这个变量赋值为0.

结果不断更新为这个变量的最大值。

很好理解，要一段连续区间，如果变量值小于0，显然不优，如果要继续更新，则前面的值就舍去。

```
	for(int i=1;i<=n;i++)
	{
		tmp+=a[i];
		if(tmp<0)tmp=0;
		ans=max(tmp,ans);
	}
```

#### T2

原题。~~不会的枪毙~~

将（n-1）个从a移动到b，将第n个移动到c，再将（n-1）个从b移动到c 递归下去。

#### T3

设f（n）为步数。有abc三根柱子。

将（n-1）个盘子先移动到c，用f（n-1），然后第n个移动到b，再将（n-1）移动到a，将第n个移动到c，再将（n-1）移动到c。

f（n）=3*f（n-1）+2；

f（1）=2。

#### T4

可以用DP。

f[i]=min(f[i],f[j]*2+d[n-j])   (1<=j<i) d[n]为在三根柱子时移动次数。

不能把上面的盘子移动到两个塔上，不然下面的不能放，很显然不成立。

所以将n分为j和n-j 先将j在四根柱子的情况下移动到2/3塔上，再将n-j在三个柱子的情况下移动到第四个塔上，再将j在四根柱子的情况下移动到第四个塔上。

#### T5

板子题，~~不会枪毙~~  ~~直接sort~~

直接将两组数据合并到一组，然后敲模板。

#### T6

先给字符串来个sort，然后开始递归遍历。开bool数组 vis[i]记录第i个字符是否被选入。

每次递归都从第一个字符遍历，判断是否被加入了结果串。如果没加入，就加进去，并继续下一次递归，注意vis数组的回复。

结果串长度足够时，直接输出并返回。

#### T7

归并板子上加几行代码就ok。如果左半边的某数字比右半边某数字大，则左半边剩下的数字都比它大。结果加上去就行了。

#### T8

~~可以一遍for循环记录一下位置直接过~~  归并排序是稳定的排序，相同的数的相对位置不改变，

可以记录数值的同时记录数字的位置，归并排序完之后遍历一下找到第一个大于等于该数的值，直接输出位置即可。