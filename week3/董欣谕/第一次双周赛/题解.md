1.运用动态规划，

f[i]表示以i为结尾的最大子段和

初始化时f[i]为该元素的值。

遍历数组时若a[i]>f[i-1]+a[i]，则更新f[i]为a[i],否则f[i]就为f[i-1]+a[i],

故状态转移方程为f[i]=max(f[i-1]+a[i],a[i]);

2.此汉诺塔问题见上次作业的题解。

3.若移动k个圆盘从第一根柱子到第三根柱子需要Fun(k)次移动，那么，先移动K-1个圆盘道第三根柱子需要Fun(k-1)次移动，再将最大的圆盘移动到中间柱子需要1次移动，然后将k-1个圆盘移动回第一根柱子同样需要Fun(k-1)次移动，移动最大的盘子到第三根柱子需要1次移动，最后将k-1个圆盘也移动到第三根柱子需要Fun(k-1)次移动，这样递归公式就是Fun(k)=3*Fun(k-1)+2。而递归的出口是k=1时，F(1)=2。

4.运用动态规划，
f[i] 表示为3根柱子i层塔时，最小的移动次数
dp[i] 表示4根柱子i层塔时，最小的移动次数
显然f[i]就是一般的汉诺塔时，其状态转换方程为f[i] = 2 * f[i - 1] + 1
当有4根柱子时，就可以分为以下几个过程
设有n层塔

先移动k层塔到另一个柱子
将剩下的n - k层塔移到一个空白柱子
将那k层塔移到n-k层塔上面
于是转换方程为
dp[n] = min(dp[n], 2 * dp[k] + f[n - k]) {k | 0 <= k <= n};

5.此题可直接使用sort，简单直接。

6.此题可使用C++的排列组合函数next_permutation()，轻松搞定。

7.用归并排序可求逆序对。

考试时tle了三遍，居然是因为爆int......

对于归并排序，因为涉及到a[i]和a[j]两两比较，每次二分完成后。对于局部已经排序好的a[]数组，如果i<j并且此时的a[i]>a[j]，说明从i到mid均有a[i]>a[j]，所以总的逆序对数目sum+=mid-i+1。

8.此题可使用C++的二分查找函数lower_bound()，秒杀。
