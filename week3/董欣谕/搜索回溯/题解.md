1. dfs模板

   用邻接表存路径，然后很传统地搜索+回溯，找到有这个一条路径则标记为true，最后标记为假则没有安全路径，路径为真则有，输出即可。

2. 记忆化搜索

   在dfs时用mem数组替代vis数组，表示经过这个点可到终点的路径个数。

   具体过程为：

   首先将mem数组初始化为-1，表示未访问，定义一个变量ans来临时记录一个点可到终点的路径个数

   在dfs时若点t无出度，则返回mem[t]=0，同时这也说明逻辑不自洽，做个标记；

   如果访问到终点，则返回mem[t]=1；

   注意在for循环遍历每个点的边时将dfs结果加给ans；

   最后再将mem[t]赋值为ans。

   如果在dfs时如果mem[t]不为-1，则直接返回该值即可，这么做避免了点的重复访问，提高了时间效率。

3. 模拟题意+dfs

   用两个二维数组存矩阵，一个表示是否有雷，另一个表示用户输出界面。

   从输入的点开始dfs，记录访问的点八个方向雷的个数，如果个数不为0则继续dfs，同时将用户界面的该点赋值。

   注意此题的格式问题。

4. 因为每个点如果可以到邻近的点，则邻近的点也可以到这个点，即每一个连通块内符合题目条件（0的点邻近的点为1，1的点临近的点为0）的点可以到达的格子个数相同，所以这道题可以划分连通块求，每个连通块上的点答案一样。注意到此题查询次数m<=100000非常大，如果每次都dfs（bfs）肯定要超时，所以采用预处理，将每个点的答案都求出来，查询时直接输出对应的值。预处理其实就是对每个没访问过的点进行dfs，统计经过的点的个数，最后统一将这个计数赋值给该连通块的编号对应的ans数组元素。

   