# 7-1 最大子段和

## 题目

> 给定n个整数（可能为负数）组成的序列a[1],a[2],a[3],…,a[n]，求该序列如a[i]+a[i+1]+…+a[j]的子段和的最大值。当所给的整数均为负数时，定义子段和为0。
>
> 要求算法的时间复杂度为O(n)。

## 输入格式

> 输入有两行：
>
> 第一行是n值（1<=n<=10000)；
>
> 第二行是n个整数。

## 输出格式

> 输出最大子段和。

## 解题思路

> 不断将数字读取累加，若加法结束后当前的和小于0，将当前结果置零，否则与当前最大子段和比较。
>
> 即：
>
> ```
> for (i=0; i < n; i++)
> 	{
> 		if (Han[i] > 0) break;
> 	}
> 	for (; i < n; i++)
> 	{
> 		sum += Han[i];
> 		if (sum < 0) sum = 0;
> 		else if (sum > maxsum) maxsum = sum;
> 	}
> ```

# 7-2 汉诺塔问题

## 题目

> 给定一个由n个圆盘组成的塔，这些圆盘按照大小递减的方式套在第一根桩柱上。现要将整个塔移动到另一根桩柱上，每次只能移动一个圆盘，且较大的圆盘在移动过程中不能放置在较小的圆盘上面。

## 输入格式

> 输入由四行： 第一行是圆盘数量n(1<=n<=10); 第二行到第四行分别是三根桩柱的名字(字符串)，n个盘子套在第一根桩柱上。

## 输出格式

> 输出移动步骤，每行输出一步。

## 解题思路

> 对于当前n个圆盘，先将n-1个圆盘移动到除起始处与目的处之外的第三处再将第n个圆盘，移动到目的处，
>
> 再将n-1个圆盘移动到目的处。层层递归直至n==1。
>
> 即：
> 
> ```
> void Han(int n, int s, int e)
> {
> 	if (n == 1)
> 	{
> 		cout << a[s] << "->" << a[e] << endl;
> 		return;
> 	}
> 	Han(n - 1, s, 3 - s - e);
> 	cout << a[s] << "->" << a[e] << endl;
> 	Han(n - 1, 3 - s - e, e);
> }
> ```

# 7-3 汉诺塔3

## 题目

> 约19世纪末，在欧州的商店中出售一种智力玩具，在一块铜板上有三根杆，最左边的杆上自上而下、由小到大顺序串着由64个圆盘构成的塔。目的是将最左边杆上的盘全部移到右边的杆上，条件是一次只能移动一个盘，且不允许大盘放在小盘的上面。 现在我们改变游戏的玩法，不允许直接从最左(右)边移到最右(左)边(每次移动一定是移到中间杆或从中间移出)，也不允许大盘放到下盘的上面。 Daisy已经做过原来的汉诺塔问题和汉诺塔II，但碰到这个问题时，她想了很久都不能解决，现在请你帮助她。现在有N个圆盘，她至少多少次移动才能把这些圆盘从最左边移到最右边？

## 输入格式

> 包含多组数据，每次输入一个N值(1<=N=35)。

## 输出格式

> 对于每组数据，输出移动最小的次数。

## 解题思路

> 对于当前n个圆盘，先将n-1个圆盘移动到目的处再将第n个圆盘，即非起始处也非目的出外的第三处，
>
> 再将n-1个圆盘移动到目的处。层层递归直至n==1。
>
> 即：
>
> PS:此处为了节省时间采用动态规划，但思想上依旧是递归思想。
>
> ```
> for (i = 2; i < 37; i++)
> 		Han[i] = 3 * Han[i - 1] + 2;
> ```

# 7-4 汉诺塔2

## 题目

> 经典的汉诺塔问题经常作为一个递归的经典例题存在。可能有人并不知道汉诺塔问题的典故。汉诺塔来源于印度传说的一个故事，上帝创造世界时作了三根金刚石柱子，在一根柱子上从下往上按大小顺序摞着64片黄金圆盘。上帝命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一回只能移动一个圆盘。有预言说，这件事完成时宇宙会在一瞬间闪电式毁灭。也有人相信婆罗门至今仍在一刻不停地搬动着圆盘。恩，当然这个传说并不可信，如今汉诺塔更多的是作为一个玩具存在。G a r d o n就收到了一个汉诺塔玩具作为生日礼物。G a r d o n是个怕麻烦的人（恩，就是爱偷懒的人），很显然将64个圆盘逐一搬动直到所有的盘子都到达第三个柱子上很困难，所以G a r d o n决定作个小弊，他又找来了一根一模一样的柱子，通过这个柱子来更快的把所有的盘子移到第三个柱子上。下面的问题就是：当G a r d o n在一次游戏中使用了N个盘子时，他需要多少次移动才能把他们都移到第三个柱子上？很显然，在没有第四个柱子时，问题的解是2^N-1，但现在有了这个柱子的帮助，又该是多少呢？

## 输入格式

> 包含多组数据，每个数据一行，是盘子的数目N(1<=N<=64)。

## 输出格式

> 对于每组数据，输出一个数，到达目标需要的最少的移动数。

## 解题思路

> 若n==1，结果是1，若n==2，结果是3；
>
> n>2时：（此处设定A、B、C、D四根柱子，C为最终目的）
>
> 先将x个盘子移动到B柱，这样剩下三个柱子与正常的汉诺塔问题相同，采用汉诺塔的结果来计算剩余n-x个盘子的移动步骤。依次迭代直至n==1或n==2，再将不同的取x值所需步骤进行比较得到最短步骤。
>
> 即：
>
> PS:此处为了节省时间采用动态规划，但思想上依旧是递归思想。
>
> ```c++
> for (j = 1; j < i; j++)
> 		{
> 			cnt = 2 * F[j] + pow(2, i - j) - 1;
> 			if (min > cnt) min = cnt;
> 		}
> ```

# 

# 7-5 简单的归并

## 题目

> 已知数组A和B各有m、n个元素，且元素按值非递减排列，现要求把A和B归并为一个新的数组C，且C中的数据元素仍然按值非递减排列。 例如，若A=(3，5，8，11)，B=(2，6，8，9，11，15，20)， 则C=(2，3，5，6，8，8，9，11，11，15，20)

## 输入格式

> 首先输入一个正整数T，表示测试数据的组数，然后是T组测试数据。 每组测试数据输入两行，其中第一行首先输入A的元素个数m（1≤m≤100），然后输入m个元素。第2行首先输入B的元素个数n（1≤n≤100），然后输入n个元素。

## 输出格式

> 对于每组测试数据。分别输出将A、B合并后的数组C的全部元素。输出的元素之间以一个空格分隔（最后一个数据之后没有空格）。

## 解题思路

> 不断将需要比较的数列尽可能二分直至不可再分，之后依照将两段数列有序合并成一段数列的算法进行排序。
>
> 二分算法：
>
> ```
> void number_sort(int a[], int l, int r)
> {
> 	if (l >= r) return;
> 	else
> 	{
> 		int mid = (r + l) / 2;
> 		number_sort(a, l, mid);
> 		number_sort(a, mid + 1, r);
> 		merge(a, l, mid, r);
> 	}
> }
> ```
>
> 排序算法：
>
> ```
> void merge(int a[], int l, int mid, int r)
> {
> 	int newa[100001], i, j, k;
> 	for (i = l; i <= r; i++)
> 		newa[i - l] = a[i];
> 	i = l, j = mid + 1;
> 	for (k = l; k <= r; k++)
> 	{
> 		if (i > mid)
> 		{
> 			a[k] = newa[j - l];
> 			j++;
> 		}
> 		else if (j > r)
> 		{
> 			a[k] = newa[i - l];
> 			i++;
> 		}
> 		else if (newa[i-l]<newa[j-l])
> 		{
> 			a[k] = newa[i - l];
> 			i++;
> 		}
> 		else
> 		{
> 			a[k] = newa[j - l];
> 			j++;
> 		}
> 	}
> }
> ```
>
> PS:此处我的代码采用sort函数直接解决，sort函数在数据较小时使用插入排序等较为简单的排序，数据较大时才采用归并排序

# 7-6 字符串的全排列

## 题目

> 给定一个全由小写字母构成的字符串，求它的全排列，按照字典序从小到大输出。

## 输入格式

> 一行，一个字符串，长度不大于8。

## 输出格式

> 输出所有全排列，每行一种排列形式，字典序从小到大。

## 解题思路

> 运用深度优先探索思想递归调用。
>
> ```c++
> for (k = 0; k < n; k++)
> 	{
> 		if (visited[k] == 0)
> 		{
> 			a[len++] = c[k];//把当前的数字放进数组，并且本层的len值加1
> 			visited[k] = 1;//把当前的数字加1
> 			perm(c,n, len);//递归调用，继续往下深入，如若满足了len==n 就做输出，然后执行下面的还原语句
> 			len--;//因为当前层次的len值做了加1 要还原本层的len值，就要len--；
> 			visited[k] = 0;//把当前数字的标记去掉，然后返回上一层，继续再往下执行
> 		}
> 	}
> ```

# 7-7 逆序对

## 题目

> 求逆序对。

## 输入格式

> 第一行是一个整数n，（n<=1000,000）表示输入序列的长度，接下来一行是n个整数(每个数的绝对值小于109)。

## 输出格式

> 一个数，表示逆序对个数(逆序即任意一对数前面的数比后面的数大即为一对逆序对)。

## 解题思路

> 归并时若mid之后的数归并入原数时是计数器增加mid+1-i（即有mid+1-i个数比当前数大却排在前面）。
>
> ```c++
> else if (newni[i - left] > newni[j - left])
> 		{
> 			ni[k] = newni[j - left];
> 			j++;
> 			cnt = cnt + mid - i + 1;
> 		}
> if (i > mid)
> 		{
> 			ni[k] = newni[j - left];
> 			j++;
> 			cnt += mid - i + 1;
> 		}
> ```

# 7-8 二分查找

## 题目

> 请实现有重复数字的有序数组的二分查找。
>
> 输出在数组中第一个大于等于查找值的位置，如果数组中不存在这样的数，则输出数组长度加一。

## 输入格式

> 输入第一行有两个数，第一个数为数组长度n（≤10^6），第二个数为需要查找的数。
>
> 接下来有n个整数，以空格或换行符分隔。

## 输出格式

>输出待查找的数的位置。

## 解题思路

> 找出中央位置，若此处的数据符合条件，则退出，否则若大则right=mid-1，若小则left=mid+1。
>
> ```c++
> int han(int n, int number)
> {
> 	int l, r, mid;
> 	l = 0, r = n - 1;
> 	
> 	while (l <= r)
> 	{
> 		mid = (r + l) / 2;
> 		if (arrayf[mid] >= number && arrayf[mid - 1] < number) return mid + 1;
> 		else if (arrayf[mid] >= number)
> 		{
> 			r = mid - 1;
> 		}
> 		else if (arrayf[mid - 1] < number) l = mid + 1;
> 	}
> 	if (number > arrayf[n - 1]) return n + 1;
> }
> ```

# 















