生化危机：

​		看到题面，考虑用dfs对该图进行遍历，注意存边时要存双向边，dfs时用pan数组判断能否遍历下一个点，从起点开始遍历，如果能遍历到终点即有安全路径，不能则没有。

​		存图用vec，方便又轻松。



那就别担心了：

​		看到体面，果断用dfs遍历，然后非常果断的t掉，~~然后因为不会剪枝选择remake~~，然后在董神的教导下我成功学会了计搜（仅限这道题）。对于某些重复遍历的点，遍历一遍后我们就能知道从这个点到终点有多少条路线。考虑用一个数组来存该点到终点的路线数，并将该数组初始化为-1。当我们算出该点的路线数时，将该数组更新，在每次dfs时，如果数组值不为-1，直接返回数组值，这样的操作能为我们省去很多多余的遍历，从而大大提高效率。

​		在实现方面，将dfs改成int类型的函数，如果数组被更新直接返回数组值，否则对每个儿子进行遍历，算出所有儿子的值的和，将数组更新并返回该值。对于逻辑自洽的判定，可以通过判断每个节点的儿子个数，如果该节点没有儿子且该点不为终点，则逻辑不自洽。如果通过每个点的出度进行判断，注意图中可能有不连边的孤点，该点的出度也为零，注意对其的判断。



扫雷：

​		对于这种方格图，一般都可采用bfs对其进行遍历，考虑一个数组存雷的位置，一个存周围有几颗雷，一个存该点是否被打开，对于每次点击进行一次bfs更新状态，注意对题意的理解，认清什么时候更新状态，什么时候压入队列，然后用一个cnt存储打开方格的个数，用它判断什么时候游戏结束。

​		因为该题目限制条件较多，代码容易出bug，建议自己构造一些比较复杂的数据多多调试。

​		注意这个图的坐标是从0开始的，为了编写方便并避免可能发生的错误，建议输入坐标时将每个坐标都+1，这样在1到n上进行处理，避免有可能的数组越界。



01矩阵：

​		同上，一般采用bfs进行遍历，考虑到m的值可能比较大，我们需要尽量减少每次查询消耗的时间，考虑对图进行预处理，O（1）地进行查询。用一个数组存图，一个数组存该位置是否可以被更新，一个存该点能遍历到的数量。存完图后，对每个答案数组没更新过的点进行遍历，跑两遍bfs，第一遍用于对每个可扩展的点进行扩展，找到这片区域的答案，并标记这篇区域的每个点，第二遍用于将算出的答案赋予每个有标记的点，并将标记去掉，这样我们就可以得到一个答案数组，并可以快速的输出答案了。



