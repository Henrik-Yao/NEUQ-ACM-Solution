最大子段和：

​		这是一道经典dp，传统做法为n方暴力扫，该dp思路为，枚举每个子段的结尾，运用贪心的思想，如果dp[i-1]<0,即dp[i-1]+a[i]一定小于a[i]，这时不妨直接去掉dp[i-1],只取a[i]为以i为结尾的最大字段和，否则就把dp[i-1]+a[i]作为以i为结尾的最大字段和，在遍历过程中对所有dp[i]的值取最大，即为该区间最大字段和。

汉诺塔1：

​		这是上一周的经典例题，详见上周题解。

汉诺塔3：

​		这是一道汉诺塔问题的扩展。运用类似汉诺塔1的思路寻找递归关系，可以发现，假设需要把n个圆盘从最左面移动到最右面，需要先将n-1个圆盘移动到最右面，再将第n个圆盘移动到中间，在将n-1个圆盘移动到最左面，在将第n个圆盘移动到最右面，在将n-1个圆盘移动到最右面，整理得An= 3(An-1)+2,即An=（3n次）-1。注意计算次幂尽量不用pow。（pow狗都不用）

汉诺塔2：

​		这是一道比较复杂的汉诺塔问题的扩展，我们需要尽量将该问题转化成经典汉诺塔问题的形式。对于n个圆盘，可以先将i个圆盘移动到一个柱子上，然后将剩余的n-i个盘子移动到需要的位置，再将i个盘子移动到需要的位置，移动i个盘子的次数可以递归计算，而移动n-i个盘子的次数即为经典汉诺塔问题。遍历所有的i，就可已找到最小的一个次数。可以将所有的次数记录下来，可以大大减少递归次数。

简单的归并：

​		sort

字符串的排列；

​		可以对字符串进行sort，然后进行dfs，输出的内容即为符合字典序的内容。用一个栈来存放储存的字母，每次top达到n就输出栈中内容。

逆序对：

​		~~sort~~

​		需要用到归并排序，在每次的归并排序中，当右半部分的数插入到前面时，右半部分的数的下标一定是大于左半部分的数的，插入到前面即表明这个数小于左半部分剩余的所有数，即所有的这些剩余的数即为逆序对。

二分查找：

​		1

​		写一个搜索，不断二分寻找指定的数，注意控制边界

​		2

​		int pos=lower_bound(a+1,a+n+1,k)-a;

​		lower_bound:输出在该数组中第一个大于等于k的数的位置的指针，减去数组名即为该位置。

​		（感谢董神的教导）

