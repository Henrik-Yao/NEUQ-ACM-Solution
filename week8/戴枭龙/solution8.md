# 7-1 最少失约

某天，诺诺有许多活动需要参加。但由于活动太多，诺诺无法参加全部活动。请帮诺诺安排，以便尽可能多地参加活动，减少失约的次数。假设：在某一活动结束的瞬间就可以立即参加另一个活动。

### 输入格式:

首先输入一个整数T，表示测试数据的组数，然后是T组测试数据。每组测试数据首先输入一个正整数n，代表当天需要参加的活动总数，接着输入n行，每行包含两个整数i和j（0≤i<j<24），分别代表一个活动的起止时间。

### 输出格式:

对于每组测试，在一行上输出最少的失约总数。

### 输入样例:

```in
1
5
1 4
3 5
3 8
5 9
12 14
```

### 输出样例:

```out
2
```

### 分析：

贪心：贪每次最早结束，这样就能尽可能多的参加。

首先对结束时间排序。

选择最早结束的活动开始，跳过相冲突的活动

重复上一步，直至活动为空

```c++
#include <bits/stdc++.h>
using namespace std;
int T, n;
struct times {
	int s;
	int e;
} ;
times t[1000];

bool cmp(times s1, times s2) {
	return s1.e < s2.e;
}

int main() {
	cin >> T;
	while (T--) {
		cin >> n;
		int cnt = 0;
		for (int i = 1; i <= n; i++) {
			cin >> t[i].s >> t[i].e;
		}
		int i = 0;
		sort(t + 1, t + n + 1, cmp);
		for (int j = 1; j <=n; j++) {
			if (t[j].s >= t[i].e) {
				i = j;
				cnt++;
			}
		}
		cout << n - cnt << endl;
	}
	return 0;
}
```



# 7-2 跳一跳

**Drizzle** 面前有一条由一堆`非负整数`组成的道路，从第一个数字起步，每次他都能跳出不大于当前数字的距离，每个数字之间的距离为1，那么他最少需要跳多少次才能到达终点？

### 要求:

输入：第一行输入道路中数字的个数`n`也就是道路的长度，第二行输入这n个数字

输出：输出一个数字，表示最少跳跃次数

### 示例:

输入:

```in
5
2 3 1 1 4结尾无空行
```

输出:

```out
2



结尾无空行
```

解释: 跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。

### 范围:

对于 20% 的数据：n≤100
对于 100% 的数据：n≤1000000
所有整数元素在`int`范围内

### 分析：

典型的贪心算法，通过局部最优解得到全局最优解。

要从覆盖范围出发，不管怎么跳，覆盖范围内一定是可以跳到的，以最小的步数增加覆盖范围，覆盖范围一旦覆盖了终点，得到的就是最小步数。

需要统计两个覆盖范围，当前这一步的最大覆盖和下一步最大覆盖。

**以最小的步数增加最大的覆盖范围，直到覆盖范围覆盖了终点**

```c++
#include <bits/stdc++.h>
using namespace std;

int main() {
	int n;
	int a[1000002];
	cin >> n;
	for (int i = 0; i < n; i++) {
		cin >> a[i];
	}
	int curDistance = 0;
	int ans = 0;
	int nextDistance = 0;
	for (int i = 0; i < n - 1; i++) {
		nextDistance = max(a[i] + i, nextDistance);
		if (i == curDistance) {
			curDistance = nextDistance;
			ans++;
		}
	}
	cout << ans << endl;
}
```

