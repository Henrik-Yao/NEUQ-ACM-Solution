# 8-1
贪心法
以结束时间为第一关键字，开始时间为第二关键字排序；
然后进行时间复杂度O（n）的查找
最后输出【n-（可参与的活动）】

# 8-2
暴力过的，不知道有没有更简便的方法
目标是从0位置跳到到n-1位置及以后
结束条件就是i+road【i】》=n-1；
达不到结束条件就直接枚举后面road【i】范围内能到最远位置的那一个下标
我在程序里写的是i=flag——1，为什么不是直接i=flag在于for循环每次都会i++；