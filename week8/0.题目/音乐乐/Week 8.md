# Week 8

## 8-1 最少失约

---

按照活动的结束时间进行排序，第一个活动肯定能参加，然后依次往后排，如果时间不冲突就可以参加，要不然就咕咕咕，计算咕咕咕的次数。



## 8-2 跳一跳

---

第一遍我自己用DP写的大概数据上也是对的，大概是：

```c++
	for(i=0;i<n;i++)
	{
		for(j=i+1;j<=i+a[i]&&j<n;j++)
		{
			dp[j]=min(dp[j],dp[i]+1);
		}
	}
```

不过因循环此处过多而爆。。。瞄了题解，优化的地方在于少了很多循环的起点。大概是在now位置上遍历now能够到达的范围[now+1,now+a[now]]，找到这个范围内最大的数据，标记对应的位置temp，在[now,temp]之间就不可能有更优的位置了，直接不考虑（所以比我写的少循环了很多次），但是在[temp+1,now+a[now]]可能有跳得更远的。保存这个跳得最远的位置。这相当于是“观望”的一步。如此每走一步就观望一步，可以保证最后走出来的步数最少。

