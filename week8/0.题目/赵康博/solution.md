### 7 - 1

---

和最长上升子序列一样，在每个会议上记录前面的最大上升序列，在s[i]上判断之前的每一个数，如果i的会议开始时间比j的结束时间晚，则储存的数组f[i] = f[j] + 1和f[i]较大的，相当于在原有的最大子序列和在j处的最大子序列加一后的结果取较大的更新f。如果结束的时间比较早则不能作为s[j]后续无法更新，在每个s[i]循环后判断最大值，最后输出。在输入的时候不一定是有先后顺序的要先调整顺序。

---

```
 for(int j = 1; j < m; j++)
        {
            for(int k = 0; k < j; k++)
            {
                if(s[j].start>=s[k].end)
                {
                    x[j] = max(x[j],x[k]+1);
                }
            }
            max1 = max(max1,x[j]);
        }
```

### 7 - 2

---

要到最少的次数到达终点，即每次都做最优的选择，在每一步中，遍历所有的能到达的范围的点，找到可以跳最远的那一个，最为下一个点，直到点的范围包含终点。

---

```
while(1)
    {
        int max1 = f[t] + t;
        int tmp = t;
        for(int i = t + 1; i <= f[t]+t; i++)
        {
            if(f[i]+i>max1)
            {
                max1 = f[i]+i;
                tmp = i;
            }
        }
        t = tmp;
        count++;
        if(f[t]+t>=n)break ;
    }
```

