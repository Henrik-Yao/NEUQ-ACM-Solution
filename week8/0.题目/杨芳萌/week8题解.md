### 最少失约

很显然是个DP

我们设 *f[i]* 是参加第 *i* 个事件的情况下所能参加的最大事件

其实我们可以把这些事件按照开始时间排序，然后把他们放在一个时间轴上，比如我们现在遍历到了第 *i* 个事件，然后我们看他前面的 *i-1* 个事件，从中选出一个事件 *x* （ *x* 事件与 *i* 事件不冲突），使得 *f[x]* 最大，那么我们就可以把 *i* 这件事接在 *x* 后面，即 *f[i] = f[x]+1*

最后，最少的失约数即为 *n - max{ f[i] }*   

O(n^2)

### 跳一跳

n的数据范围是1e6，因此考虑线性

我们先考虑最暴力的做法：现在我们站在第 *i* 个数字上，数字为 *a[i]* ，那么我们有可能跳到 *i+1, i+2, i+3, ……, i+a[i]* 的数字上，就把 *i+1, i+2, i+3, ……, i+a[i]* 的答案更新成为 *f[i] + 1* 不过更新答案的时候需要考虑比起原有的状态哪个更优。但这显然是 *O(n^2)* 的，过不去1e6。

那么如果不考虑dp呢，万一这只是一个简单的贪心题呢

思路：在能跳的区间里先筛选出最大的数，再从最大的数到能跳到的区间里筛选出最优的位置，一直到能跳到终点的地方终止。