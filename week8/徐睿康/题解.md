最小失约：

​		这道题也是一道贪心，最小失约即最大参与活动数，注意并不是一天中用的时间越多参与活动就越多。用结构体存下输入，将每个活动以开始时间从小到大排序，然后从1到n开始dfs，每层再扫一遍数组，若第i个位置的开始时间大于当前位置的结束时间就继续dfs，每深入一层cnt++，最后找到一个最大的cnt。



跳一跳：

​		这道题血交五遍，终于是做出来了。

​		看到这道题第一个想到的就是bfs，几周前有一个非常类似的题也是在区间上跳啊跳，那道题的正解就是bfs，然后写了个简单的bfs，于是t的非常彻底。这道题，不是bfs还能是啥呢？我甚至写了个神奇的带点贪心的并查集上去，发现wa的很彻底，我的思路是sort一遍优先把大的数包括的位置并在一起，比如i位置上的数是2，就把i，i+1，i+2全部并在一个虚根（比如0）下面并cnt++，如果1的祖先和n的祖先相同就输出，是一个标准的假算法，因为根本无法证明它的正确性。

​		然后过了一天，我注意到和这道题同为week8的题是一道贪心，所以我想一定和贪心沾点关系，并查集一定是错的，所以我又看回了我的bfs，考虑优化下暴力的bfs，突然我想到，能不能优先跳到这个区间最大的数上，如果相同就优先跳到更后面的位置，比如3 1 2 1 5从第一个数开始跳，在1 2 1 中优先跳到数字为2这个位置上，以前面那串数为例，可以证明的是，对于2之前的数字，跳到2上一定是更优的。因为首先2之前的数一定比2小，不然会跳到那个更大的数上，然后，跳到2上有更大的可能离n更近一些，因为2的位置比它之前的数更靠近n，且数字2比之前的所有数都大，所以2一定是更优的。我并没有证明对于后面的数的正确性，所以就又wa了一遍。考虑对后面的数，我发现随便构造一个数据就能卡掉我的这个算法，比如3 2 1 1 5这串数，以我的算法会先跳到2上，再跳到第二个1上，再跳到5上，但是正解一定是先跳到第二个1再跳到5上。为什么呢？我发现2和第一个1是等价的，因为它们都最多只能覆盖到第二个1，而且它们都同属于第一个3的范围内。然而2和第二个1是不等价的，因为第二个1能覆盖到5而2不行，我意识到最优的效果是会随着往后寻找而衰退的。我让寻找最大数的maxx每次循环都减一，相当于最优效果的衰退，然后其他不变，这样对于这个例子因为循环到第一个1时maxx-1即2-1得到了1与第一个1等价，而第一个1位置更靠后，所以取第一个1，循环到第二个1时maxx-1即1-1得到了0小于第二个1，所以取第二个1，这样取到的就是最优解了。

