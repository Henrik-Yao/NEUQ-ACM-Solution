# Solution

## 7-1

主要就是经典的kmp算法

有个注意点就是next数组名字直接叫next的话会冲突，换个名字就好了

next[i]的值表示下标为i的字符前的字符串最长相等前后缀的长度

在这里就需要去看一下**最长相等前后缀的长度**的定义了

简言之就是i对应字符前面所有字符串里面的最长的重复的字符串的长度

这个就是每次移动的距离，对比暴力效率高了一些



## 7-2

涉及哈希的使用，以及我去了解了map的使用

`map<string,string>kuzi;`

有点类似数组，`kuzi[name]=mima;`

意思就是name这个字符串对应的是mima这个字符串

本来想用结构体做的，但是看见大佬们的题解就去看了map的使用

那么剩下的难点就是哈希函数了，看上去还是很复杂的，这个耗时间



## 7-3

这里了解了一些新的函数

`getline(cin,a);`

这是读入函数，但是他可以读入空格

有些读入方式遇到空格就会中断

`S[ddl]+=a[i];`

这个是在一个字符串里面存入另一个字符串

`if(S[i].find(b)!=-1)s++;`

这是一个find查找函数

比kmp简单好多www

以我的理解就相当于sort函数和我自己写的排序函数差不多

