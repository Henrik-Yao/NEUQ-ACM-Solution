1. KMP字符串匹配

   预处理next数组（前缀后缀最长公共元素长度），然后进行匹配。

   具体过程为：

   假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置
   如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++，继续匹配下一个字符；
   如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串P相对于文本串S向右移动了j - next [j] 位。
   换言之，当匹配失败时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值，即移动的实际位数为：j - next[j]，且此值大于等于1。

   由于本题需要计算匹配的个数，所以当匹配成功后需要将i--，并将j赋值为next[j-1]，即模式串向左移动到前一个匹配的位置继续进行匹配。

2. 字符串哈希

   将每个密码用map进行两次存储，一次用真实密码存储，还有一次用哈希值存储，然后模拟题意即可。

   注意：计算哈希值的字符串需要先将字符串赋值为“”，然后再存储字符。

3. 暴力STL find函数直接分段搜
