### 7 - 1

---

kmp的典型题，需要注意的是由于是可重复叠的，所以在判断一个与模式串相同之后，不从后面直接开始，而是要返回最后一个字符不相同的情况，继续认证next[j]对应的前面的是否成立，这样判断的都是可能成立的不会重复的判断。

```c++
    while (i!=s1)
    {
     if(s[i]==t[j]||j == -1){
         i++;
         j++;
         if(j==t1)
         {
         i--;
         sum++;
         j = Next[j-1];
         } 
     }
     else
     {
         j = Next[j];
     }
    }
```

### 7 - 2

---

用map的话比较好过，写完题中的计算方法后，由于账号也可能有碰撞的概率，用map存储比较简单，先用node[name] = password，把不同人对应的密码都储存起来，在取最后一位数字时对36取余，最后算出来总的值，存入map中，最后与输入的密码比较，若不相同，在判断一下运算的结果是否相同。

```c++
if(node[t]==m)cout<<"Success!";
    else if(Su(node[t])==Su(m))cout<<"Attention!";
    else cout<<"Failed!";
```

### 7 - 3

---

和第一题的差别不大，主要是先把字符串都小写（或者大写）然后分开储存，之后再用kmp就行，分字符串的时候，判断若是大写就变成小写存入，若是小写直接存就行，可以用string += 'a'存入，回车返回，不是字母或回车则continue知道遇到字母或者回车。

```
 while (1)
    {
        if(t>='a'&&t<='z')s[i]+=t;
        else if(t>='A'&&t<='Z')s[i]+=t - 'A' + 'a';
        else if(t == '\n')break;
        else {
            t = getchar();
            if(t>='a'&&t<='z'||t>='A'&&t<='Z'){
                i++;
            }
            continue;
        }
        t = getchar();
    }
```

